<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/tnds-notebooks/libs/katex/katex.min.css"> <link rel=stylesheet  href="/tnds-notebooks/libs/highlight/github.min.css"> <link rel=stylesheet  href="/tnds-notebooks/css/franklin.css"> <link rel=stylesheet  href="/tnds-notebooks/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/tnds-notebooks/assets/favicon.png"> <title>Lezione 7</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <h1><a href="/tnds-notebooks/">TNDS</a></h1> <p class=lead >Prof. M.&nbsp;Tomasi</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/tnds-notebooks/">Home</a> <a class="sidebar-nav-item active" href="/tnds-notebooks/lezione07/">Lezione 07</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione08/">Lezione 08</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione10/">Lezioni 10 e 11</a> </nav> <p>&copy; Maurizio Tomasi.</p> </div> </div> <div class="content container"> <div class=franklin-content > <p><div class=franklin-toc ><ol><li><a href="#installazione_di_julia">Installazione di Julia</a><li><a href="#introduzione">Introduzione</a><li><a href="#esercizio_70_integrazione_con_la_formula_del_mid-point">Esercizio 7.0 – Integrazione con la formula del mid-point</a><li><a href="#errore_del_metodo_mid-point">Errore del metodo mid-point</a><li><a href="#esercizio_71_integrazione_alla_simpson">Esercizio 7.1 – Integrazione alla Simpson</a><li><a href="#metodo_dei_trapezoidi">Metodo dei trapezoidi</a><li><a href="#esercizio_72_integrazione_con_trapezoidi_a_precisione_fissata">Esercizio 7.2 – Integrazione con trapezoidi a precisione fissata</a><li><a href="#esercizio_73_integrazione_di_una_funzione_gaussiana_facoltativo">Esercizio 7.3 – Integrazione di una funzione Gaussiana &#40;facoltativo&#41;</a></ol></div> </p> <p>In questo documento mostro come implementare gli algoritmi di integrazione numerica visti durante la lezione 7. È una utile traccia per capire quali risultati dovete aspettarvi, perché fornisce i numeri da usare negli <code>assert</code> del vostro codice.</p> <p>Invece di fornire gli esempi di codice in C&#43;&#43;, ho scelto di usare il linguaggio <a href="https://julialang.org/">Julia</a>, per i seguenti motivi:</p> <ul> <li><p>Non fornendo codici C&#43;&#43;, vi obbligo ad implementare tutto da soli come nelle lezioni precedenti;</p> <li><p>Il linguaggio Julia è molto semplice da leggere, e non richiede competenze particolari per essere compreso;</p> <li><p>Essendo questo un notebook, include sia le spiegazioni che gli esempi di codice e gli output.</p> </ul> <p>Tenete conto in Julia non esiste incapsulamento, e l&#39;ereditarietà e il polimorfismo sono implementati in maniera diversa dal C&#43;&#43;, quindi il modo in cui sono implementati i codici è profondamente diverso. Essendo un linguaggio pensato per applicazioni scientifiche, la notazione di Julia è molto «matematica», e non dovrebbe essere difficile per voi capire cosa faccia il codice.</p> <h2 id=installazione_di_julia ><a href="#installazione_di_julia" class=header-anchor >Installazione di Julia</a></h2> <p>Questo documento è un documento creato con Julia e i pacchetti <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a> e <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.</p> <p>Julia è un linguaggio di programmazione moderno pensato soprattutto per la scrittura di codici numerici e scientifici. È più semplice del C&#43;&#43; ma, a differenza di altri linguaggi «facili» come Python, è estremamente potente. Non è consigliabile installare Julia sui computer del laboratorio, a causa dello scarso spazio disponibile nelle home. Le istruzioni in questo paragrafo possono esservi utili se desiderate installare Julia sul vostro computer.</p> <p>Scaricate l&#39;eseguibile per il vostro ambiente dal sito https://julialang.org/ &#40;al momento la versione più recente è la 1.8&#41;. Avviate poi Julia &#40;da Linux eseguite <code>julia</code>, mentre sotto Windows e Mac OS X dovrebbe essere presente un&#39;icona&#41;, ed installate alcuni pacchetti che saranno utili per questa lezione e la prossima.</p> <pre><code class="julia hljs"><span class=hljs-keyword >import</span> Pkg
Pkg.add(<span class=hljs-string >&quot;Plots&quot;</span>)
Pkg.add(<span class=hljs-string >&quot;IJulia&quot;</span>)</code></pre> <p>Una volta eseguiti i comandi, potete continuare a lavorare da linea di comando nel prompt di <code>julia</code>, oppure aprire notebook esistenti e crearne di nuovi con questi due comandi:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> IJulia
jupyterlab(dir=<span class=hljs-string >&quot;.&quot;</span>)</code></pre> <p>Appena eseguite queste istruzioni, dovrebbe aprirsi il vostro browser Internet &#40;Firefox, Safari, …&#41; e mostrare la pagina di Jupyter-Lab, l&#39;interfaccia che consente di gestire i notebook.</p> <h2 id=introduzione ><a href="#introduzione" class=header-anchor >Introduzione</a></h2> <p>Iniziamo col caricare due librerie che ci serviranno. In Julia si caricano librerie col comando <code>import</code> &#40;l&#39;analogo di <code>#include</code> in C&#43;&#43;&#41;:</p> <pre><code class="julia hljs"><span class=hljs-keyword >import</span> Statistics

<span class=hljs-comment ># In C++ si sarebbe scritto: Statistics::mean</span>
<span class=hljs-comment ># (&quot;Statistics&quot; è un namespace)</span>
Statistics.mean([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>])</code></pre><pre><code class="plaintext hljs">2.0</code></pre>
<p>Notate che in Julia i namespace sono molto più ordinati che in C&#43;&#43;: se si scrive <code>import Statistics</code>, questo non è messo nel namespace <code>std</code> &#40;come sarebbe stato in C&#43;&#43;&#41;, ma nel namespace <code>Statistics</code>. &#40;Bjarne Stroustrup, il creatore del C&#43;&#43;, ha dichiarato in una conferenza che se potesse tornare indietro rivedrebbe il modo in cui il namespace <code>std</code> è stato usato fino ad oggi&#33;&#41;</p>
<p>Esiste il comando <code>using</code>, che equivale alla combinazione in C&#43;&#43; di <code>#include</code> e <code>using namespace</code>:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Statistics

<span class=hljs-comment ># Non è più necessario scrivere `Statistics.mean`</span>
mean([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>])</code></pre><pre><code class="plaintext hljs">2.0</code></pre>
<p>Nella lezione di oggi dovremo calcolare numericamente degli integrali. Useremo come esempio la funzione <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>=</mo><mi>x</mi><mi>sin</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">f(x) = x \sin(x)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span>, sapendo che</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn></mrow></msubsup><mi>x</mi><mi>sin</mi><mo>⁡</mo><mi>x</mi><mtext> </mtext><mi mathvariant=normal >d</mi><mi>x</mi><mo>=</mo><msubsup><mrow><mo fence=true >[</mo><mi>sin</mi><mo>⁡</mo><mi>x</mi><mo>−</mo><mi>x</mi><mi>cos</mi><mo>⁡</mo><mi>x</mi><mo fence=true >]</mo></mrow><mn>0</mn><mrow><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn></mrow></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\int_0^{\pi/2} x \sin x\,\mathrm{d}x = \left[\sin x - x \cos x\right]_0^{\pi/2} = 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:2.54985em;vertical-align:-0.9119499999999999em;"></span><span class=mop ><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.6379000000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/2</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.3276em;vertical-align:-0.29969999999999997em;"></span><span class=minner ><span class=minner ><span class="mopen delimcenter" style="top:0em;">[</span><span class=mop >sin</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >cos</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.0278999999999998em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/2</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.29969999999999997em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span></span>
<p>Useremo molto anche la capacità di Julia di creare liste mediante la sintassi</p>
<pre><code class="julia hljs">result = [f(x) <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> input]</code></pre>
<p>che equivale al codice seguente:</p>
<pre><code class="julia hljs">result = [f(input[<span class=hljs-number >1</span>]), f(input[<span class=hljs-number >2</span>]), f(input[<span class=hljs-number >3</span>]), …]</code></pre>
<p>Vediamo un esempio: creiamo un array <code>list</code> che contenga i valori <code>1, 2, 3</code>, e poi creiamo un nuovo array <code>out</code> che contenga il quadrato dei numeri in <code>list</code>, ossia <code>1, 4, 9</code>. In C&#43;&#43; avremmo dovuto scrivere</p>
<pre><code class="cpp hljs">std::vector&lt;<span class=hljs-type >int</span>&gt; list{<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>};
<span class=hljs-function >std::vector&lt;<span class=hljs-type >int</span>&gt; <span class=hljs-title >out</span><span class=hljs-params >(ssize(list))</span></span>;   <span class=hljs-comment >// Round parentheses here!</span>
<span class=hljs-keyword >for</span> (<span class=hljs-type >size_t</span> i{}; i &lt; list.<span class=hljs-built_in >size</span>(); ++i) {
    <span class=hljs-comment >// Save the squared value of list[i] into out[i]</span>
    out[i] = list[i] * list[i];
}

<span class=hljs-comment >// Now `out` contains the values {1, 4, 9}</span></code></pre>
<p>In Julia è tutto molto più semplice:</p>
<pre><code class="julia hljs">list = [<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>]
<span class=hljs-comment ># This gets expanded in [1*1, 2*2, 3*3], which is [1, 4, 9]</span>
out = [x * x <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> list]</code></pre>
<h2 id=esercizio_70_integrazione_con_la_formula_del_mid-point ><a href="#esercizio_70_integrazione_con_la_formula_del_mid-point" class=header-anchor >Esercizio 7.0 – Integrazione con la formula del mid-point</a></h2>
<p>Testo dell&#39;esercizio: <a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-07.html#esercizio-7.0">carminati-esercizi-07.html</a>.</p>
<p>Il metodo del mid-point consiste nell&#39;approssimare l&#39;integrale con il valore del punto della funzione <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> nel punto medio dell&#39;intervallo:</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mtext> </mtext><mi mathvariant=normal >d</mi><mi>x</mi><mo>≈</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>h</mi><mo>⋅</mo><mi>f</mi><mrow><mo fence=true >(</mo><mi>a</mi><mo>+</mo><mrow><mo fence=true >(</mo><mi>k</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo fence=true >)</mo></mrow><mi>h</mi><mo fence=true >)</mo></mrow><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex">
\int_a^b f(x)\,\mathrm{d}x \approx
\sum_{k = 0}^{n - 1} h \cdot f\left(a + \left(k + \frac12\right) h\right).
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class=mop ><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.5990080000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:3.1032260000000003em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.8011130000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class=pstrut  style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class=pstrut  style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class=pstrut  style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:1.302113em;"><span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >⋅</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord mathnormal">a</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.32144em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >2</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >.</span></span></span></span></span>
<p>In Julia non esistono classi, quindi non è possibile definire una classe <code>Integral</code>: si usa una tecnica più adatta per i calcoli che si usano in fisica, basata sul <em>multiple dispatch</em>.</p>
<p>In Julia possiamo quindi immediatamente implementare il metodo del mid-point tramite una semplice funzione <code>midpoint</code>. Non specifichiamo il tipo di <code>f</code>, né di <code>a</code> o di <code>b</code> &#40;in Julia si può, e anzi di solito si fa così&#33;&#41;, ma specifichiamo quello di <code>n</code>: il motivo sarà chiaro quando risolveremo l&#39;<a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-07.html#esercizio-7.2">esercizio 7.2</a>. Il tipo <code>Integer</code> è l&#39;analogo di una classe astratta in C&#43;&#43;, ed è il padre di tutti quei tipi che rappresentano numeri interi &#40;<code>Int</code>, <code>Int8</code>, <code>UInt32</code>, etc.&#41;. La scrittura <code>n::Integer</code> dice a Julia che <code>midpoint</code> può accettare qualsiasi tipo di valore per <code>f</code>, <code>a</code> e <code>b</code>, ma <code>n</code> deve essere per forza un numero intero.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> midpoint(f, a, b, n::<span class=hljs-built_in >Integer</span>)
    h = (b - a) / n
    h * sum([f(a + (k + <span class=hljs-number >0.5</span>) * h) <span class=hljs-keyword >for</span> k <span class=hljs-keyword >in</span> <span class=hljs-number >0</span>:(n - <span class=hljs-number >1</span>)])
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">midpoint (generic function with 1 method)</code></pre>
<p>La scrittura <code>&#91;f&#40;a &#43; &#40;k &#43; 0.5&#41; * h&#41; for k in 0:&#40;n - 1&#41;&#93;</code> è l&#39;analogo della notazione matematica</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mo fence=true >{</mo><mi>f</mi><mo fence=true  stretchy=true  minsize=1.2em  maxsize=1.2em >(</mo><mi>a</mi><mo>+</mo><mo stretchy=false >(</mo><mi>k</mi><mo>+</mo><mn>0.5</mn><mo stretchy=false >)</mo><mi>h</mi><mo fence=true  stretchy=true  minsize=1.2em  maxsize=1.2em >)</mo><mo separator=true >,</mo><mi>k</mi><mo>∈</mo><mn>0</mn><mo>…</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo fence=true >}</mo></mrow><annotation encoding="application/x-tex">\left\{f\bigl(a + (k + 0.5) h\bigr), k \in 0\ldots n - 1 \right\}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.20001em;vertical-align:-0.35001em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">{</span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen ><span class="delimsizing size1">(</span></span><span class="mord mathnormal">a</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mord >0.5</span><span class=mclose >)</span><span class="mord mathnormal">h</span><span class=mclose ><span class="delimsizing size1">)</span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mord >0</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=minner >…</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mord >1</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">}</span></span></span></span></span></span></span>
<p>e il risultato dell&#39;espressione è un array di valori che viene passato alla funzione <code>sum</code>, la quale ovviamente ne calcola la somma. In Julia non c&#39;è quindi bisogno di implementare un ciclo <code>for</code> &#40;cosa che invece dovrete fare nella vostra implementazione C&#43;&#43; del midpoint&#41;.</p>
<p>Possiamo invocare <code>midpoint</code> senza bisogno di definire una classe che implementi il calcolo di <code>f&#40;x&#41;</code>: in Julia si possono definire funzioni “anonime” &#40;ossia, senza un nome come <code>f</code>&#41; con la sintassi <code>x -&gt; espressione</code>. Ecco come calcolare l&#39;integrale di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>sin</mi><mo>⁡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x\sin x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.66786em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span></span></span></span> sull&#39;intervallo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0, \pi / 2]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mord >/2</span><span class=mclose >]</span></span></span></span> con 10 passi:</p>
<pre><code class="julia hljs">midpoint(x -&gt; x * sin(x), <span class=hljs-number >0</span>, <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>, <span class=hljs-number >10</span>)</code></pre><pre><code class="plaintext hljs">0.9989696941917652</code></pre>
<p>Il risultato è confortante: non è molto dissimile da 1, che è il valore calcolabile analiticamente.</p>
<p>Vediamo cosa succede cambiando il numero di passi:</p>
<pre><code class="julia hljs">midpoint(x -&gt; x * sin(x), <span class=hljs-number >0</span>, <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>, <span class=hljs-number >100</span>)</code></pre><pre><code class="plaintext hljs">0.999989718940119</code></pre>
<p>Verifichiamo anche che il segno cambi se invertiamo gli estremi:</p>
<pre><code class="julia hljs">midpoint(x -&gt; x * sin(x), <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>, <span class=hljs-number >0</span>, <span class=hljs-number >10</span>)</code></pre><pre><code class="plaintext hljs">-0.998969694191765</code></pre>
<p>Notate la semplicità con cui è stata chiamata la funzione: a differenza della programmazione OOP in C&#43;&#43;, qui non abbiamo dovuto derivare una classe <code>Seno</code> dalla classe <code>FunzioneBase</code> e ridefinire un metodo <code>Eval</code> che chiamasse <code>x * sin&#40;x&#41;</code>.</p>
<p>Definiamo per maggiore comodità la funzione <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span>:</p>
<pre><code class="julia hljs">xsinx(x) = x * sin(x)</code></pre><pre><code class="plaintext hljs">xsinx (generic function with 1 method)</code></pre>
<p>&#40;funzioni brevi per cui basta una riga di codice possono essere implementati con questa sintassi, anziché quella che usa <code>function</code> che abbiamo impiegato sopra per <code>midpoint</code>&#41;.</p>
<p>Possiamo ora invocare <code>midpoint</code> passando direttamente <code>xsinx</code>:</p>
<pre><code class="julia hljs">midpoint(xsinx, <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>, <span class=hljs-number >0</span>, <span class=hljs-number >10</span>)</code></pre><pre><code class="plaintext hljs">-0.998969694191765</code></pre>
<p>Con i numeri ottenuti potreste già implementare dei test nel vostro codice C&#43;&#43;. Però il caso <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn></mrow></msubsup><mi>x</mi><mi>sin</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mtext> </mtext><mi mathvariant=normal >d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_0^{\pi/2} x \sin(x)\,\mathrm{d}x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.43872em;vertical-align:-0.35582em;"></span><span class=mop ><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.0829em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/2</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.35582em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span></span></span></span> è un po&#39; troppo particolare per poter essere un buon caso per i test, perché &#40;1&#41; l&#39;estremo inferiore è zero, e &#40;2&#41; la funzione si annulla nell&#39;estremo sinistro.</p>
<p>Il problema è che alcune formule di integrazione che vedremo oggi richiedono un trattamento speciale agli estremi di integrazione, e un caso come questo potrebbe far passare inosservati dei bug importanti &#40;<strong>è successo a molti studenti in passato&#33;</strong>&#41;. Calcoliamo il valore dell&#39;integrale con questo algoritmo in due casi meno banali:</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>x</mi><mi>sin</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mtext> </mtext><mi mathvariant=normal >d</mi><mi>x</mi><mo separator=true >,</mo><mspace width=2em /><msubsup><mo>∫</mo><mn>1</mn><mn>2</mn></msubsup><mi>x</mi><mi>sin</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mtext> </mtext><mi mathvariant=normal >d</mi><mi>x</mi><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex">
\int_0^1 x \sin(x)\,\mathrm{d}x, \qquad
\int_1^2 x \sin(x)\,\mathrm{d}x.
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:2.4759580000000003em;vertical-align:-0.9119499999999999em;"></span><span class=mop ><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.5640080000000003em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span><span class=mpunct >,</span><span class=mspace  style="margin-right:2em;"></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop ><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.5640080000000003em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span><span class=mord >.</span></span></span></span></span>
<pre><code class="julia hljs">println(<span class=hljs-string >&quot;Primo integrale:   &quot;</span>, midpoint(xsinx, <span class=hljs-number >0</span>, <span class=hljs-number >1</span>, <span class=hljs-number >10</span>))
println(<span class=hljs-string >&quot;Secondo integrale: &quot;</span>, midpoint(xsinx, <span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >30</span>))</code></pre><pre><code class="plaintext hljs">Primo integrale:   0.3005925674684609
Secondo integrale: 1.440482828731412
</code></pre>
<p>In C&#43;&#43; possiamo quindi usare i seguenti <code>assert</code>:</p>
<pre><code class="cpp hljs"><span class=hljs-function ><span class=hljs-type >int</span> <span class=hljs-title >test_midpoint</span><span class=hljs-params >()</span> </span>{
  XSinX xsinx{};
  Midpoint mp{};

  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(i.<span class=hljs-built_in >Integrate</span>(<span class=hljs-number >0</span>, numbers::pi / <span class=hljs-number >2</span>, <span class=hljs-number >10</span>, xsinx),
                   <span class=hljs-number >0.9989696941917652</span>);
  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(i.<span class=hljs-built_in >Integrate</span>(<span class=hljs-number >0</span>, numbers::pi / <span class=hljs-number >2</span>, <span class=hljs-number >100</span>, xsinx),
                   <span class=hljs-number >0</span>999989718940119);
  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(i.<span class=hljs-built_in >Integrate</span>(numbers::pi / <span class=hljs-number >2</span>, <span class=hljs-number >0</span>, <span class=hljs-number >10</span>, xsinx),
                   <span class=hljs-number >-0.998969694191765</span>);
  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(mp.<span class=hljs-built_in >integrate</span>(<span class=hljs-number >0</span>, <span class=hljs-number >1</span>, <span class=hljs-number >10</span>, xsinx),
                   <span class=hljs-number >0.3005925674684609</span>));
  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(mp.<span class=hljs-built_in >integrate</span>(<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >30</span>, xsinx),
                   <span class=hljs-number >1.440482828731412</span>));
  fmt::<span class=hljs-built_in >println</span>(stderr, <span class=hljs-string >&quot;The midpoint function works correctly! 🥳&quot;</span>);
}</code></pre>
<p>D&#39;ora in poi non fornirò più liste di <code>assert</code> belle e pronte, ma dovrete voi ricavare i numeri dagli output di Julia e scrivere gli <code>assert</code> corrispondentemente. Ormai avete fatto esperienza&#33;</p>
<h2 id=errore_del_metodo_mid-point ><a href="#errore_del_metodo_mid-point" class=header-anchor >Errore del metodo mid-point</a></h2>
<p>Calcoliamo ora l&#39;andamento dell&#39;errore rispetto alla funzione di riferimento <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>=</mo><mi>sin</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">f(x) = \sin(x)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span>.</p>
<pre><code class="julia hljs">steps = [<span class=hljs-number >10</span>, <span class=hljs-number >20</span>, <span class=hljs-number >50</span>, <span class=hljs-number >100</span>, <span class=hljs-number >200</span>, <span class=hljs-number >500</span>, <span class=hljs-number >1000</span>]
errors = [abs(midpoint(xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>, n) - <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> n <span class=hljs-keyword >in</span> steps]

<span class=hljs-keyword >using</span> Plots
plot(steps, errors, xlabel = <span class=hljs-string >&quot;Numero di passi&quot;</span>, ylabel = <span class=hljs-string >&quot;Errore&quot;</span>)</code></pre>
<img src="/tnds-notebooks/assets/lezione07/code/output/midpoint-error.svg" alt="">
<p>Il grafico precedente non è chiaro perché ci sono escursioni di alcuni ordini di grandezza sia per la variabile <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> che per la variabile <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>. Usiamo allora un grafico bilogaritmico, in cui si rappresentano i punti <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><msup><mi>x</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo separator=true >,</mo><msup><mi>y</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo stretchy=false >)</mo><mo>=</mo><mo stretchy=false >(</mo><mi>log</mi><mo>⁡</mo><mi>x</mi><mo separator=true >,</mo><mi>log</mi><mo>⁡</mo><mi>y</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(x&#x27;, y&#x27;) = (\log x, \log y)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.001892em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mclose >)</span></span></span></span> anziché <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>x</mi><mo separator=true >,</mo><mi>y</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(x,
y)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mclose >)</span></span></span></span>. Questo è l&#39;ideale per i grafici di leggi del tipo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mi>α</mi></msup></mrow><annotation encoding="application/x-tex">y =
x^\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.664392em;vertical-align:0em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span></span></span></span></span></span></span>, come si vede da questi conti:</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mtable rowspacing=0.2500em  columnalign="right left" columnspacing=0em ><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mo>=</mo><mi>C</mi><msup><mi>x</mi><mi>α</mi></msup><mo separator=true >,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mi>log</mi><mo>⁡</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mo>=</mo><mi>log</mi><mo>⁡</mo><mrow><mo fence=true >(</mo><mi>C</mi><msup><mi>x</mi><mi>α</mi></msup><mo fence=true >)</mo></mrow><mo separator=true >,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mi>log</mi><mo>⁡</mo><mi>y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mo>=</mo><mi>α</mi><mi>log</mi><mo>⁡</mo><mi>x</mi><mo>+</mo><mi>log</mi><mo>⁡</mo><mi>C</mi><mo separator=true >,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><msup><mi>y</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mo>=</mo><mi>α</mi><msup><mi>x</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo>+</mo><mi>log</mi><mo>⁡</mo><mi>C</mi><mo separator=true >,</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
y &amp;= C x^\alpha,\\
\log y &amp;= \log\left(C x^\alpha\right),\\
\log y &amp;= \alpha \log x + \log C, \\
y&#x27; &amp;= \alpha x&#x27; + \log C,
\end{aligned}
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:6em;vertical-align:-2.7500000000000004em;"></span><span class=mord ><span class=mtable ><span class=col-align-r ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:3.25em;"><span style="top:-5.41em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.91em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.4099999999999993em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-0.9099999999999997em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.7500000000000004em;"><span></span></span></span></span></span><span class=col-align-l ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:3.25em;"><span style="top:-5.41em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span></span></span></span><span class=mpunct >,</span></span></span><span style="top:-3.91em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mpunct >,</span></span></span><span style="top:-2.4099999999999993em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mpunct >,</span></span></span><span style="top:-0.9099999999999997em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mpunct >,</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.7500000000000004em;"><span></span></span></span></span></span></span></span></span></span></span></span>
<p>che è della forma <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo>=</mo><mi>m</mi><msup><mi>x</mi><mo mathvariant=normal  lspace=0em  rspace=0em >′</mo></msup><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">y&#x27; = m x&#x27; + q</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.946332em;vertical-align:-0.19444em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.835222em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>, ossia una retta, dove il coefficiente angolare <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> è proprio l&#39;esponente <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> che cerchiamo.</p>
<pre><code class="julia hljs">plot(steps, errors,
     xscale = :log10, yscale = :log10,
     xlabel = <span class=hljs-string >&quot;Numero di passi&quot;</span>, ylabel = <span class=hljs-string >&quot;Errore&quot;</span>)</code></pre>
<img src="/tnds-notebooks/assets/lezione07/code/output/midpoint-error-log.svg" alt="">
<p>Dal grafico bilogaritmico è facile stimare <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>: vedete infatti che sull&#39;asse <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> c&#39;è una escursione da 10¹ a 10³, quindi <strong>due</strong> ordini di grandezza, mentre sull&#39;asse <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> si va da 10⁻² a 10⁻⁶, ossia <strong>meno quattro</strong> ordini di grandezza. La pendenza della retta, ossia l&#39;esponente <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>, è il coefficiente angolare degli ordini di grandezza: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mo>−</mo><mn>4</mn><mi mathvariant=normal >/</mi><mn>2</mn><mo>=</mo><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha = -4/2 = -2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >−</span><span class=mord >4/2</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >−</span><span class=mord >2</span></span></span></span>, che è esattamente quanto ci aspettavamo, perché l&#39;errore deve essere <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>∝</mo><msup><mi>N</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\epsilon \propto N^{-2}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∝</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>Nel vostro codice vorrete probabilmente creare un grafico come questo. Siccome la realizzazione di grafici può essere complessa, il mio consiglio è quello di stampare dapprima i numeri a video usando <code>cout</code> o <code>fmt::print</code>, e solo una volta che sembrano ragionevoli procedere a creare il plot. Dovreste quindi scrivere l&#39;equivalente in C&#43;&#43; del seguente codice Julia:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> eachindex(steps)  <span class=hljs-comment ># `i` will go from 1 to the length of `step`</span>
    <span class=hljs-comment ># In Julia, writing $() in a string means that the expression</span>
    <span class=hljs-comment ># within parentheses gets evaluated and the result substituted</span>
    <span class=hljs-comment ># in the string. The &#x27;\t&#x27; character is the TAB, of course</span>
    println(<span class=hljs-string >&quot;<span class=hljs-subst >$(steps[i])</span>\t<span class=hljs-subst >$(errors[i])</span>&quot;</span>)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">10	0.0010303058082348215
20	0.0002571597110612167
50	4.112690319824086e-5
100	1.0281059880989929e-5
200	2.5702233518165585e-6
500	4.112338719552966e-7
1000	1.028084013476871e-7
</code></pre>
<p>Implementiamo ora una funzione che consenta di calcolare rapidamente l&#39;errore di una funzione di integrazione numerica per un dato numero di passi di integrazione: ci servirà per studiare non solo il metodo del mid-point, ma anche i metodi di Simpson e dei trapezi.</p>
<p>Inizializziamo per prima cosa le costanti che caratterizzano il caso che useremo come esempio, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mi>π</mi></msubsup><mi>sin</mi><mo>⁡</mo><mi>x</mi><mtext> </mtext><mi mathvariant=normal >d</mi><mi>x</mi><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\int_0^\pi\sin x\,\mathrm{d}x = \pi</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.215112em;vertical-align:-0.35582em;"></span><span class=mop ><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8592920000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.35582em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>: la funzione da integrare &#40;<code>REF_FN</code>&#41;, gli estremi &#40;<code>REF_A</code> e <code>REF_B</code>&#41;, e il valore esatto dell&#39;integrale &#40;<code>REF_INT</code>&#41;.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >const</span> REF_FN = xsinx;  <span class=hljs-comment ># La funzione da integrare</span>
<span class=hljs-keyword >const</span> REF_A = <span class=hljs-number >0</span>;       <span class=hljs-comment ># Estremo inferiore di integrazione</span>
<span class=hljs-keyword >const</span> REF_B = <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>;  <span class=hljs-comment ># Estremo superiore di integrazione</span>
<span class=hljs-keyword >const</span> REF_INT = <span class=hljs-number >1</span>;     <span class=hljs-comment ># Valore dell&#x27;integrale noto analiticamente</span></code></pre>
<p>La funzione <code>compute_errors</code> calcola il valore assoluto della differenza tra la stima dell&#39;integrale con la funzione <code>fn</code> &#40;che può essere ad esempio <code>midpoint</code>&#41; e il valore vero dell&#39;integrale, <code>REF_INT</code>.</p>
<pre><code class="julia hljs">compute_errors(fn, steps) = [abs(fn(REF_FN, REF_A, REF_B, n) - REF_INT)
                             <span class=hljs-keyword >for</span> n <span class=hljs-keyword >in</span> steps]</code></pre><pre><code class="plaintext hljs">compute_errors (generic function with 1 method)</code></pre>
<p>Applichiamo <code>compute_errors</code> alla funzione <code>midpoint</code>:</p>
<pre><code class="julia hljs">errors = compute_errors(midpoint, steps)</code></pre><pre><code class="plaintext hljs">7-element Vector{Float64}:
 0.0010303058082348215
 0.0002571597110612167
 4.112690319824086e-5
 1.0281059880989929e-5
 2.5702233518165585e-6
 4.112338719552966e-7
 1.028084013476871e-7</code></pre>
<p>Come ricavare la legge di potenza dovrebbe essere ovvio dal discorso fatto sopra circa i grafici bilogaritmici… Se nel grafico logaritmico la curva si riduce a una retta, basta calcolare la pendenza della retta passante per i due punti estremi, che in Julia hanno indice <code>1</code> &#40;gli array in Julia non iniziano da 0&#41; e <code>end</code> &#40;che in Julia indica l&#39;ultima posizione in un array&#41;:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> error_slope(steps, errors)
    deltax = log(steps[<span class=hljs-keyword >end</span>]) - log(steps[<span class=hljs-number >1</span>])
    deltay = log(errors[<span class=hljs-keyword >end</span>]) - log(errors[<span class=hljs-number >1</span>])

    deltay / deltax
<span class=hljs-keyword >end</span>

error_slope(steps, errors)</code></pre><pre><code class="plaintext hljs">-2.0004687710597153</code></pre>
<p>Domanda: È importante nell&#39;implementazione di <code>error_slope</code> sopra fissare la base del logaritmo, oppure no? In altre parole, si ottengono risultati diversi se si usa <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\log_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.93858em;vertical-align:-0.24414em;"></span><span class=mop ><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">\log_{10}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.93858em;vertical-align:-0.24414em;"></span><span class=mop ><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span> oppure <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">\log_e</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.93858em;vertical-align:-0.24414em;"></span><span class=mop ><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.057252em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.24414em;"><span></span></span></span></span></span></span></span></span></span>?</p>
<h2 id=esercizio_71_integrazione_alla_simpson ><a href="#esercizio_71_integrazione_alla_simpson" class=header-anchor >Esercizio 7.1 – Integrazione alla Simpson</a></h2>
<p>Testo dell&#39;esercizio: <a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-07.html#esercizio-7.1">carminati-esercizi-07.html</a>.</p>
<p>Si usa la formula</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msubsup><mo>∫</mo><mi>a</mi><mi>b</mi></msubsup><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mtext> </mtext><mi mathvariant=normal >d</mi><mi>x</mi><mo>≈</mo><mrow><mo fence=true >(</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy=false >)</mo><mo>+</mo><mfrac><mn>4</mn><mn>3</mn></mfrac><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy=false >)</mo><mo>+</mo><mfrac><mn>2</mn><mn>3</mn></mfrac><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy=false >)</mo><mo>+</mo><mo>…</mo><mo>+</mo><mfrac><mn>4</mn><mn>3</mn></mfrac><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mrow><mi>N</mi><mo>−</mo><mn>2</mn></mrow></msub><mo stretchy=false >)</mo><mo>+</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy=false >)</mo><mo fence=true >)</mo></mrow><mi>h</mi><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex">
\int_a^b f(x)\,\mathrm{d}x \approx \left(
\frac13 f(x_0) +
\frac43 f(x_1) +
\frac23 f(x_2) +
\ldots +
\frac43 f(x_{N - 2}) +
\frac13 f(x_{N - 1})
\right) h,
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:2.5109580000000005em;vertical-align:-0.9119499999999999em;"></span><span class=mop ><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.5990080000000004em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.40003em;vertical-align:-0.95003em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.32144em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >3</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.32144em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >3</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >4</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.32144em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >3</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=minner >…</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.32144em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >3</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >4</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.32144em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >3</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">h</span><span class=mpunct >,</span></span></span></span></span>
<p>con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>k</mi></msub><mo>=</mo><mi>a</mi><mo>+</mo><mi>k</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">x_k = a + k h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">a</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">kh</span></span></span></span>.</p>
<p>Come sopra, implementiamo l&#39;algoritmo senza definire classi &#40;come faremmo in C&#43;&#43;&#41;, ma scrivendo direttamente una funzione.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simpson(f, a, b, n::<span class=hljs-built_in >Integer</span>)
    <span class=hljs-comment ># Siccome il metodo funziona solo quando il numero di</span>
    <span class=hljs-comment ># intervalli è pari, usiamo &quot;truen&quot; anziché &quot;n&quot; nei</span>
    <span class=hljs-comment ># calcoli sotto</span>
    truen = (n % <span class=hljs-number >2</span> == <span class=hljs-number >0</span>) ? n : (n + <span class=hljs-number >1</span>)

    h = (b - a) / truen
    acc = <span class=hljs-number >1</span>/<span class=hljs-number >3</span> * (f(a) + f(b))
    <span class=hljs-keyword >for</span> k = <span class=hljs-number >1</span>:(truen - <span class=hljs-number >1</span>)
        acc += <span class=hljs-number >2</span>/<span class=hljs-number >3</span> * (<span class=hljs-number >1</span> + k % <span class=hljs-number >2</span>) * f(a + k * h)
    <span class=hljs-keyword >end</span>

    acc * h
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">simpson (generic function with 1 method)</code></pre>
<p>Verifichiamone il funzionamento sul nostro caso di riferimento. Anche questi numeri sono utili per implementare degli assert nel vostro codice C&#43;&#43;; in particolare, il metodo di Simpson usa coefficienti per estremi <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>a</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">a</span><span class=mclose >)</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>b</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">f(b)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">b</span><span class=mclose >)</span></span></span></span> che sono diversi da quelli per i punti intermedi, quindi gli ultimi due test sono particolarmente importanti&#33;</p>
<pre><code class="julia hljs">println(<span class=hljs-string >&quot;Primo caso:   &quot;</span>, simpson(xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>, <span class=hljs-number >10</span>))
println(<span class=hljs-string >&quot;Secondo caso: &quot;</span>, simpson(xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>, <span class=hljs-number >100</span>))
println(<span class=hljs-string >&quot;Terzo caso:   &quot;</span>, simpson(xsinx, <span class=hljs-number >0</span>, <span class=hljs-number >1</span>, <span class=hljs-number >10</span>))
println(<span class=hljs-string >&quot;Quarto caso:  &quot;</span>, simpson(xsinx, <span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >30</span>))</code></pre><pre><code class="plaintext hljs">Primo caso:   0.9999898033639686
Secondo caso: 0.9999999989852724
Terzo caso:   0.3011669731757114
Quarto caso:  1.4404224289997802
</code></pre>
<p>Come ho scritto sopra, stavolta non fornisco gli <code>assert</code> da usare nel vostro codice: dovreste essere in grado di implementarli da soli usando i quattro risultati. È molto importante che implementiate tutti e quattro i test, perché in questo modo verificate che la vostra implementazione consideri correttamente il valore dell&#39;integranda su più estremi di integrazione.</p>
<p>Passiamo ora a calcolare gli errori del metodo di Simpson, usando ancora una volta un grafico bilogaritmico.</p>
<pre><code class="julia hljs">errors = compute_errors(simpson, steps)

plot(steps, errors,
     xscale = :log10, yscale = :log10,
     xlabel = <span class=hljs-string >&quot;Numero di passi&quot;</span>, ylabel = <span class=hljs-string >&quot;Errore&quot;</span>)</code></pre>
<img src="/tnds-notebooks/assets/lezione07/code/output/simpson-error.svg" alt="">
<p>Verifichiamo che la pendenza sia quella attesa: l&#39;errore <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> dovrebbe essere tale che <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>∝</mo><msup><mi>N</mi><mrow><mo>−</mo><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\epsilon \propto N^{-4}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∝</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<pre><code class="julia hljs">error_slope(steps, errors)</code></pre><pre><code class="plaintext hljs">-4.00128795505442</code></pre>
<h2 id=metodo_dei_trapezoidi ><a href="#metodo_dei_trapezoidi" class=header-anchor >Metodo dei trapezoidi</a></h2>
<p>In questo caso si approssima l&#39;integrale con l&#39;area del trapezio.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> trapezoids(f, a, b, n::<span class=hljs-built_in >Integer</span>)
    h = (b - a) / n
    acc = (f(a) + f(b)) / <span class=hljs-number >2</span>
    <span class=hljs-keyword >for</span> k <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:(n - <span class=hljs-number >1</span>)
        acc += f(a + k * h)
    <span class=hljs-keyword >end</span>

    acc * h
<span class=hljs-keyword >end</span>

println(<span class=hljs-string >&quot;Primo caso:   &quot;</span>, trapezoids(xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>, <span class=hljs-number >10</span>))
println(<span class=hljs-string >&quot;Secondo caso: &quot;</span>, trapezoids(xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >pi</span> / <span class=hljs-number >2</span>, <span class=hljs-number >100</span>))
println(<span class=hljs-string >&quot;Terzo caso:   &quot;</span>, trapezoids(xsinx, <span class=hljs-number >0</span>, <span class=hljs-number >1</span>, <span class=hljs-number >10</span>))
println(<span class=hljs-string >&quot;Quarto caso:  &quot;</span>, trapezoids(xsinx, <span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >30</span>))</code></pre><pre><code class="plaintext hljs">Primo caso:   1.0020587067645337
Secondo caso: 1.0000205619295077
Terzo caso:   0.30232058249393656
Quarto caso:  1.4403016069813432
</code></pre>
<p>Come al solito, usate questi quattro risultati per implementare degli <code>assert</code> nel vostro programma C&#43;&#43;.</p>
<p>Facciamo un plot come prima:</p>
<pre><code class="julia hljs">errors = compute_errors(trapezoids, steps)
plot(steps, errors,
     xscale = :log10, yscale = :log10,
     xlabel = <span class=hljs-string >&quot;Numero di passi&quot;</span>, ylabel = <span class=hljs-string >&quot;Errore&quot;</span>)</code></pre>
<img src="/tnds-notebooks/assets/lezione07/code/output/trapezoids-error.svg" alt="">
<p>Calcoliamo anche la pendenza della curva <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>∝</mo><msup><mi>N</mi><mi>α</mi></msup></mrow><annotation encoding="application/x-tex">\epsilon \propto N^\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∝</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span></span></span></span></span></span></span>:</p>
<pre><code class="julia hljs">error_slope(steps, errors)</code></pre><pre><code class="plaintext hljs">-2.000267963930007</code></pre>
<p>Tracciamo ora un grafico comparativo dei due metodi.</p>
<pre><code class="julia hljs">plot(steps, compute_errors(midpoint, steps),
     label = <span class=hljs-string >&quot;Mid-point&quot;</span>,
     xscale = :log10, yscale = :log10,
     xlabel = <span class=hljs-string >&quot;Numero di passi&quot;</span>,
     ylabel = <span class=hljs-string >&quot;Errore&quot;</span>)
plot!(steps, compute_errors(trapezoids, steps),
      label = <span class=hljs-string >&quot;Trapezoidi&quot;</span>)
plot!(steps, compute_errors(simpson, steps),
      label = <span class=hljs-string >&quot;Simpson&quot;</span>)</code></pre>
<img src="/tnds-notebooks/assets/lezione07/code/output/error-comparison.svg" alt="">
<p>Notate che il metodo del mid-point e dei trapezi hanno la stessa legge di scala, ma non si sovrappongono: la costante <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> nella legge di scala <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>=</mo><mi>C</mi><msup><mi>N</mi><mrow><mo>−</mo><mi>α</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\epsilon = CN^{-\alpha}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ϵ</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.771331em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span></span></span></span></span></span></span></span> è diversa &#40;e quindi è diversa l&#39;intercetta <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>10</mn></msub><mi>C</mi></mrow><annotation encoding="application/x-tex">q = \log_{10} C</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.93858em;vertical-align:-0.24414em;"></span><span class=mop ><span class=mop >lo<span style="margin-right:0.01389em;">g</span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.24414em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> nel grafico bilogaritmico&#41;.</p>
<h2 id=esercizio_72_integrazione_con_trapezoidi_a_precisione_fissata ><a href="#esercizio_72_integrazione_con_trapezoidi_a_precisione_fissata" class=header-anchor >Esercizio 7.2 – Integrazione con trapezoidi a precisione fissata</a></h2>
<p>Testo dell&#39;esercizio: <a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-07.html#esercizio-7.2">carminati-esercizi-07.html</a>.</p>
<p>L&#39;esercizio 7.2 è diverso dagli esercizi 7.0 e 7.1, perché richiede di iterare il calcolo finché non si raggiunge una precisione fissata. Usiamo il suggerimento del testo per non dover ricalcolare da capo il valore approssimato dell&#39;integrale.</p>
<p>Sfruttiamo la capacità di Julia di esprimere sequenze con la sintassi <code>start:delta:end</code>:</p>
<pre><code class="julia hljs"><span class=hljs-comment ># La funzione `collect` obbliga Julia a stampare l&#x27;elenco completo</span>
<span class=hljs-comment ># degli elementi di una lista anziché usare la forma compatta (poco</span>
<span class=hljs-comment ># interessante in questo caso, perché vogliamo almeno per una volta</span>
<span class=hljs-comment ># vedere uno per uno gli elementi dell&#x27;intervallo 1:2:10)</span>
collect(<span class=hljs-number >1</span>:<span class=hljs-number >2</span>:<span class=hljs-number >10</span>)</code></pre><pre><code class="plaintext hljs">5-element Vector{Int64}:
 1
 3
 5
 7
 9</code></pre>
<p>Ora appare chiaro perché nell&#39;implementare <code>midpoint</code>, <code>simpsons</code> e <code>trapezoids</code> sopra avevamo dichiarato esplicitamente come <code>Integer</code> il tipo dell&#39;ultimo parametro, <code>n</code>: adesso vogliamo invece invocare <code>trapezoids</code> passando la precisione, che indichiamo col tipo <code>AbstractFloat</code>. Questo tipo è analogo a una classe astratta C&#43;&#43; da cui derivano i tipi floating-point, come <code>Float16</code>, <code>Float32</code>, e <code>Float64</code>.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> trapezoids(f, a, b, prec::<span class=hljs-built_in >AbstractFloat</span>)
    n = <span class=hljs-number >2</span>

    h = (b - a) / n
    <span class=hljs-comment ># Valore dell&#x27;integrale nel caso n = 2</span>
    acc = (f(a) + f(b)) / <span class=hljs-number >2</span> + f((a + b) / <span class=hljs-number >2</span>)
    newint = acc * h
    <span class=hljs-keyword >while</span> <span class=hljs-literal >true</span>
        oldint = newint
        n *= <span class=hljs-number >2</span>
        h /= <span class=hljs-number >2</span>

        <span class=hljs-keyword >for</span> k <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >2</span>:(n - <span class=hljs-number >1</span>) <span class=hljs-comment ># Just iterate on odd numbers</span>
            acc += f(a + k * h)
        <span class=hljs-keyword >end</span>

        newint = acc * h
        <span class=hljs-comment ># In Julia, the / operator always returns a floating-point</span>
        <span class=hljs-comment ># number. This is not true in C++, so remember to write 4.0/3</span>
        <span class=hljs-keyword >if</span> <span class=hljs-number >4</span>/<span class=hljs-number >3</span> * abs(newint - oldint) &lt; prec
            <span class=hljs-keyword >break</span>
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>

    <span class=hljs-comment ># L&#x27;errore 4/3 × (newint - oldint) è teoricamente</span>
    <span class=hljs-comment ># quello associato al valore `oldint` (che si riferisce</span>
    <span class=hljs-comment ># al passo h), ma restituiamo `newint` perché comunque</span>
    <span class=hljs-comment ># l&#x27;abbiamo già calcolato, e comunque sicuramente ha</span>
    <span class=hljs-comment ># un errore ≤ prec.</span>
    newint
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">trapezoids (generic function with 2 methods)</code></pre>
<p>Notate che dopo aver compilato la definizione precedente, Julia ha scritto <code>trapezoids &#40;generic function with 2 methods&#41;</code>. Ha quindi capito che abbiamo fornito una nuova implementazione di <code>trapezoids</code>, e non ha quindi sovrascritto la vecchia &#40;che accettava come ultimo argomento un intero, ossia il numero di passaggi&#41;.</p>
<p>Per verificare il funzionamento della nuova funzione <code>trapezoids</code>, possiamo verificare che l&#39;integrale calcolato sulla nostra funzione di riferimento <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>=</mo><mi>x</mi><mi>sin</mi><mo>⁡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = x \sin x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.66786em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span></span></span></span> abbia un errore sempre inferiore alla precisione richiesta.</p>
<pre><code class="julia hljs">prec = [<span class=hljs-number >1e-1</span>, <span class=hljs-number >1e-2</span>, <span class=hljs-number >1e-3</span>, <span class=hljs-number >1e-4</span>, <span class=hljs-number >1e-5</span>];
values = [trapezoids(REF_FN, REF_A, REF_B, eps) <span class=hljs-keyword >for</span> eps <span class=hljs-keyword >in</span> prec];
errors = [abs(x - REF_INT) <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> values];</code></pre>
<p>Stampiamo innanzitutto i valori di <code>prec</code> &#40;precisione&#41;, <code>values</code> &#40;integrale col metodo dei trapezoidi&#41; ed <code>errors</code> &#40;discrepanza dal valore vero&#41;, così che possiate avere dei riferimenti con cui implementare dei test mediante <code>assert</code>:</p>
<pre><code class="julia hljs">println(<span class=hljs-string >&quot;Prec\tValue of the integral\tAbsolute error&quot;</span>)

<span class=hljs-keyword >for</span> (cur_prec, cur_value, cur_error) <span class=hljs-keyword >in</span> zip(prec, values, errors)
    println(<span class=hljs-string >&quot;<span class=hljs-variable >$cur_prec</span>\t<span class=hljs-variable >$cur_value</span>\t<span class=hljs-variable >$cur_error</span>&quot;</span>)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">Prec	Value of the integral	Absolute error
0.1	1.0129507467218792	0.012950746721879236
0.01	1.0008035776793722	0.0008035776793722249
0.001	1.000200821809705	0.0002008218097049319
0.0001	1.000012549945474	1.254994547394972e-5
1.0e-5	1.0000007843660552	7.843660552175891e-7
</code></pre>
<p>Infine, facciamo un grafico bilogaritmico:</p>
<pre><code class="julia hljs">plot(prec, errors,
     label = <span class=hljs-string >&quot;Misurato&quot;</span>,
     xscale = :log10, yscale = :log10,
     xlabel = <span class=hljs-string >&quot;Precisione impostata&quot;</span>,
     ylabel = <span class=hljs-string >&quot;Precisione ottenuta&quot;</span>)
plot!(prec, prec, label = <span class=hljs-string >&quot;Caso teorico peggiore&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione07/code/output/trapezoids-vs-theory.svg" alt="">
<h2 id=esercizio_73_integrazione_di_una_funzione_gaussiana_facoltativo ><a href="#esercizio_73_integrazione_di_una_funzione_gaussiana_facoltativo" class=header-anchor >Esercizio 7.3 – Integrazione di una funzione Gaussiana &#40;facoltativo&#41;</a></h2>
<p>Testo dell&#39;esercizio: <a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-07.html#esercizio-7.3">carminati-esercizi-07.html</a>.</p>
<p>Svolgiamo infine l&#39;esercizio facoltativo al termine della lezione. Incominciamo col definire la funzione Gaussiana, e sfruttiamo la comoda possibilità che offre Julia di usare lettere greche per i nomi di variabili:</p>
<pre><code class="julia hljs">gauss(x, µ, σ) = exp(-(x - µ)^<span class=hljs-number >2</span> / <span class=hljs-number >2</span>σ^<span class=hljs-number >2</span>) / sqrt(<span class=hljs-number >2</span><span class=hljs-literal >π</span> * σ^<span class=hljs-number >2</span>)</code></pre><pre><code class="plaintext hljs">gauss (generic function with 1 method)</code></pre>
<p>Apparentemente, questa definizione è problematica: la funzione <code>gauss</code> accetta ben tre parametri, ma <code>midpoint</code> può integrare solo le funzioni che accettano <strong>un</strong> parametro&#33; Per risolvere questo problema, il testo di Carminati suggerisce di passare i valori di <code>µ</code> e <code>σ</code> al costruttore della vostra classe <code>Gaussian</code>, in modo che il metodo <code>Eval</code> debba accettare solo <code>x</code>.</p>
<p>In Julia è tutto molto più semplice grazie alla sintassi <code>x -&gt;
espressione</code>, che crea una funzione anonima usa-e-getta. Ad esempio, per calcolare l&#39;integrale della Gaussiana usando Simpson e passando un intervallo ampio, possiamo verificare se la normalizzazione è corretta:</p>
<pre><code class="julia hljs">simpson(x -&gt; gauss(x, <span class=hljs-number >1.0</span>, <span class=hljs-number >2.0</span>), -<span class=hljs-number >10.0</span>, <span class=hljs-number >10.0</span>, <span class=hljs-number >1000</span>)</code></pre><pre><code class="plaintext hljs">0.999996583337243</code></pre>
<p>Il risultato è approssimativamente 1, il che vuol dire che abbiamo implementato correttamente la Gaussiana.</p>
<p>Il grafico dell&#39;integrale col metodo dei trapezoidi è banale da produrre; assumiamo che <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mu = 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sigma = 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span>, e usiamo l&#39;istruzione <code>let</code> per definire variabili che verranno “distrutte” quando si arriva all&#39;<code>end</code> finale:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >let</span> µ = <span class=hljs-number >0.0</span>, σ = <span class=hljs-number >1.0</span>
  <span class=hljs-comment ># Do *not* start from t = 0, as the Gaussian is undefined</span>
  <span class=hljs-comment ># when σ = 0!</span>
  list_of_t = <span class=hljs-number >0.1</span>:<span class=hljs-number >0.1</span>:<span class=hljs-number >5.0</span>
  list_of_y = [trapezoids(x -&gt; gauss(x, µ, σ), -t * σ, t * σ, <span class=hljs-number >1e-5</span>)
               <span class=hljs-keyword >for</span> t <span class=hljs-keyword >in</span> list_of_t]

  plot(list_of_t, list_of_y,
       label = <span class=hljs-string >&quot;&quot;</span>,
       xlabel = <span class=hljs-string >&quot;Numero di σ&quot;</span>,
       ylabel = <span class=hljs-string >&quot;Probabilità&quot;</span>)
<span class=hljs-keyword >end</span></code></pre>
<img src="/tnds-notebooks/assets/lezione07/code/output/exercise-7.3.svg" alt="">

<div class=page-foot >
  <div class=copyright >
    &copy; Maurizio Tomasi. Last modified: November 25, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>