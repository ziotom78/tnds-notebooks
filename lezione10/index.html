<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/tnds-notebooks/libs/katex/katex.min.css"> <link rel=stylesheet  href="/tnds-notebooks/libs/highlight/github.min.css"> <link rel=stylesheet  href="/tnds-notebooks/css/franklin.css"> <link rel=stylesheet  href="/tnds-notebooks/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/tnds-notebooks/assets/favicon.png"> <title>Lezioni 10 e 11</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <h1><a href="/tnds-notebooks/">TNDS</a></h1> <p class=lead >Prof. M.&nbsp;Tomasi</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/tnds-notebooks/">Home</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione07/">Lezione 07</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione08/">Lezione 08</a> <a class="sidebar-nav-item active" href="/tnds-notebooks/lezione10/">Lezioni 10 e 11</a> </nav> <p>&copy; Maurizio Tomasi.</p> </div> </div> <div class="content container"> <div class=franklin-content > <p><div class=franklin-toc ><ol><li><a href="#esercizio_100">Esercizio 10.0</a><ol><li><a href="#generatore_lineare_congruenziale">Generatore Lineare Congruenziale</a><li><a href="#distribuzione_esponenziale">Distribuzione esponenziale</a><li><a href="#distribuzione_gaussiana">Distribuzione Gaussiana</a><li><a href="#distribuzione_gaussiana_con_metodo_accept-reject">Distribuzione Gaussiana con metodo Accept-Reject</a></ol><li><a href="#esercizio_101">Esercizio 10.1</a><li><a href="#esercizio_102">Esercizio 10.2</a><li><a href="#esercizio_120">Esercizio 12.0</a><li><a href="#esercizio_121_attrito_viscoso_facoltativo">Esercizio 12.1 — Attrito viscoso &#40;facoltativo&#41;</a></ol></div> </p> <p>Dal momento che la lezione 11 richiede di impiegare i codici sviluppati nella lezione 10, presento gli esercizi delle due lezioni in un&#39;unica pagina.</p> <h1 id=lezione_10 ><a href="#lezione_10" class=header-anchor >Lezione 10</a></h1> <p>Iniziamo importando i pacchetti che ci serviranno.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Printf
<span class=hljs-keyword >using</span> Plots
<span class=hljs-keyword >using</span> Statistics</code></pre> <h2 id=esercizio_100 ><a href="#esercizio_100" class=header-anchor >Esercizio 10.0</a></h2> <p>Definiamo una classe <code>GLC</code> che sia equivalente alla classe <code>Random</code> che vi viene richiesto di implementare in C&#43;&#43;.</p> <p>In Julia non esiste il concetto di «classe», ma esistono le <code>struct</code> che funzionano in modo concettualmente simile. Non permettono di associare metodi, tranne eventualmente un semplice costruttore, e tutti i campi sono pubblici di default.</p> <h3 id=generatore_lineare_congruenziale ><a href="#generatore_lineare_congruenziale" class=header-anchor >Generatore Lineare Congruenziale</a></h3> <pre><code class="julia hljs"><span class=hljs-keyword >mutable struct</span> GLC
    a::<span class=hljs-built_in >UInt32</span>
    c::<span class=hljs-built_in >UInt32</span>
    m::<span class=hljs-built_in >UInt32</span>
    seed::<span class=hljs-built_in >UInt32</span>

    GLC(myseed) = new(<span class=hljs-number >1664525</span>, <span class=hljs-number >1013904223</span>, <span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >31</span>, myseed)
<span class=hljs-keyword >end</span></code></pre> <p>Il tipo <code>UInt32</code> corrisponde a <code>unsigned int</code> in C&#43;&#43;.</p> <p>La strana scrittura <code>1 &lt;&lt; 31</code> è un&#39;operazione di <a href="https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts">bit shift</a>: dice di considerare il numero <code>1</code> in binario, e di spostarlo a sinistra, aggiungendo quindi alla sua destra tanti zeri quanti il secondo operando &#40;31&#41;. Ecco alcuni esempi, dove i numeri che iniziano con <code>0b</code> sono scritti in binario &#40;è una convenzione del C&#43;&#43; e di Julia&#41;:</p> <pre><code class="text hljs">0b10010 &lt;&lt; 1 == 0b100100    (uno zero aggiunto alla fine)
0b10010 &lt;&lt; 3 == 0b10010000  (tre zeri aggiunti alla fine)
0b10010 &gt;&gt; 2 == 0b100       (due cifre tolte alla fine)</code></pre> <p>Potete comprendere il significato dell&#39;operazione se pensate al caso decimale: se sposto un numero come <code>1</code> a sinistra, aggiungendo 31 zeri, lo sto moltiplicando per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">10^{31}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span>, ottenendo quindi il numero <code>1e&#43;31</code>. Analogamente, se tolgo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> cifre a destra di un numero, lo sto <em>dividendo</em> per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">10^N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8413309999999999em;vertical-align:0em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>.</p> <p>Nel caso binario, <code>1 &lt;&lt; 31</code> vuol dire moltiplicare <code>1</code> per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord ><span class=mord >2</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span>, ma quest&#39;operazione è molto più rapida che usando <code>pow&#40;&#41;</code> in C&#43;&#43; o l&#39;operatore <code>^</code> in Julia, perché il bit-shift viene fatto a livello di singoli capacitori e induttanze nella CPU, che “travasano” la carica di un bit nel bit accanto, ed è un&#39;operazione velocissima.</p> <blockquote> <p><strong>Piccola nota storica</strong></p> <p>Negli anni &#39;90 il compilatore <a href="https://en.wikipedia.org/wiki/Borland_C&#37;2B&#37;2B">Borland C&#43;&#43;</a> aveva introdotto l&#39;ottimizzazione di tradurre istruzioni come <code>x *&#61; 2</code> in <code>x &lt;&lt;&#61; 1</code>, e analogamente per la divisione intera per 2 o sue potenze. Questo aveva causato un sensibile aumento di velocità di certi codici, che la Borland aveva pubblicizzato nelle sue brochures&#33; Oggi quest&#39;ottimizzazione è diventata standard su tutti i compilatori, non solo C&#43;&#43;, ma all&#39;epoca era un trucco da “addetti ai lavori”, ed aveva suscitato molto interesse il fatto che un compilatore fosse diventato così furbo da saperla applicare in certi casi.</p> </blockquote> <p>Definiamo ora una funzione <code>rand</code> che restituisca un numero casuale floating-point compreso in un intervallo:</p> <pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >&quot;&quot;&quot;
    rand(glc::GLC, xmin, xmax)

Return a pseudo-random number uniformly distributed in the
interval [xmin, xmax).
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> rand(glc::GLC, xmin, xmax)
    glc.seed = (glc.a * glc.seed + glc.c) % glc.m
    xmin + (xmax - xmin) * glc.seed / glc.m
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">rand</code></pre>
<p>È molto comodo avere anche una funzione <code>rand</code> che usi l&#39;intervallo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>.</p>
<pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >&quot;&quot;&quot;
    rand(glc::GLC)

Return a pseudo-random number uniformly distributed in the
interval [0, 1).
&quot;&quot;&quot;</span>
rand(glc::GLC) = rand(glc, <span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>)</code></pre><pre><code class="plaintext hljs">rand</code></pre>
<p>Questi sono i numeri che dovreste aspettarvi se avete implementato bene il vostro codice &#40;notate che i numeri cambiano se usate un seed diverso&#33;&#41;.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, rand(glc))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 0.47291105054318905
2: 0.7385413474403322
3: 0.008484064601361752
4: 0.40976652735844254
5: 0.10108725726604462
</code></pre>
<p>Preoccupatevi quindi di creare una serie di <code>assert</code> nel vostro codice C&#43;&#43; che verifichino che ottenete gli stessi valori se partite dallo stesso seme &#40;<code>1</code>&#41;, possibilmente in una funzione <code>test_random_numbers&#40;&#41;</code> invocata all&#39;inizio del vostro <code>main</code>.</p>
<p>Quando si implementano numeri pseudo-casuali, è sempre bene farsi un&#39;idea della distribuzione dei valori. Disegnamo quindi l&#39;istogramma della distribuzione di un gran numero di campioni, e verifichiamo che siano uniformemente distribuiti nell&#39;intervallo &#91;0, 1&#41;.</p>
<pre><code class="julia hljs">histogram([rand(glc) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/rand_hist.svg" alt="">
<h3 id=distribuzione_esponenziale ><a href="#distribuzione_esponenziale" class=header-anchor >Distribuzione esponenziale</a></h3>
<p>Trattandosi di una formula semplice, in Julia si può definire <code>randexp</code> con una sola riga di codice:</p>
<pre><code class="julia hljs"><span class=hljs-string >&quot;&quot;&quot;
    randexp(glc::GLC)

Return a positive pseudo-random number distributed with a
probability density ``p(x) = λ e^{-λ x}``.
&quot;&quot;&quot;</span>
randexp(glc::GLC, λ) = -log(<span class=hljs-number >1</span> - rand(glc)) / λ</code></pre><pre><code class="plaintext hljs">randexp</code></pre>
<p>Questi sono i numeri per i vostri <code>assert</code>:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, randexp(glc, <span class=hljs-number >1</span>))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 0.6403859601352556
2: 1.3414791243855002
3: 0.008520259140710315
4: 0.5272371040158115
5: 0.10656930958385337
</code></pre>
<p>Questo è l&#39;istogramma</p>
<pre><code class="julia hljs">histogram([randexp(glc, <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/randexp_hist.svg" alt="">
<h3 id=distribuzione_gaussiana ><a href="#distribuzione_gaussiana" class=header-anchor >Distribuzione Gaussiana</a></h3>
<pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >raw&quot;&quot;&quot;
    randgauss(glc::GLC, μ, σ)

Return a pseudo-random number distributed with a probability
density ``p(x) = \frac{1}{\sqrt{2πσ^2}}
\exp\left(-\frac{(x - μ)^2}{2σ^2}\right)``, using the
Box-Müller algorithm.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> randgauss(glc::GLC, μ, σ)
    s = rand(glc)
    t = rand(glc)
    x = sqrt(-<span class=hljs-number >2</span>log(s)) * cos(<span class=hljs-number >2</span><span class=hljs-literal >π</span> * t)
    μ + σ * x
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">randgauss</code></pre>
<p>All&#39;interno della funzione, nella riga in cui si assegna il valore a <code>x</code>, vi sareste potuti aspettare la riga</p>
<pre><code class="julia hljs">x = sqrt(-<span class=hljs-number >2</span>log(<span class=hljs-number >1</span> - s)) * cos(<span class=hljs-number >2</span><span class=hljs-literal >π</span> * t)</code></pre>
<p>con il termine <code>2log&#40;1 - s&#41;</code> anziché <code>2log&#40;s&#41;</code>. I due termini <em>non</em> sono uguali, ovviamente, ma la loro distribuzione statistica invece sì: in entrambi i casi infatti l&#39;argomento del logaritmo è distribuito uniformemente tra 0 ed 1. Però la scrittura <code>2log&#40;s&#41;</code> risparmia una sottrazione ed è quindi lievemente più veloce.</p>
<p>Questi sono i numeri per i vostri <code>assert</code>, assumendo ovviamente che anche voi usiate <code>log&#40;s&#41;</code> anziché <code>log&#40;1 - s&#41;</code>:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, randgauss(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 1.9119660920460757
2: -0.6053171651252578
3: 1.8526405678280609
4: 2.8326279901403026
5: 1.5348644738998436
</code></pre>
<p>Questo è l&#39;istogramma:</p>
<pre><code class="julia hljs">histogram([randgauss(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/randgauss_hist.svg" alt="">
<h3 id=distribuzione_gaussiana_con_metodo_accept-reject ><a href="#distribuzione_gaussiana_con_metodo_accept-reject" class=header-anchor >Distribuzione Gaussiana con metodo Accept-Reject</a></h3>
<pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >raw&quot;&quot;&quot;
    randgauss_ar(glc::GLC, μ, σ)

Return a pseudo-random number distributed with a probability
density ``p(x) = \frac1{\sqrt{2πσ^2}}
\exp\left(-\frac{(x - μ)^2}{2σ^2}\right)``, using the
accept-reject algorithm.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> randgauss_ar(glc::GLC, μ, σ)
    <span class=hljs-keyword >while</span> <span class=hljs-literal >true</span>  <span class=hljs-comment ># Loop forever</span>
        x = rand(glc, -<span class=hljs-number >5.</span>, <span class=hljs-number >5.</span>)
        y = rand(glc)
        g = exp(-x^<span class=hljs-number >2</span> / <span class=hljs-number >2</span>)
        y ≤ g &amp;&amp; <span class=hljs-keyword >return</span> μ + x * σ
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">randgauss_ar</code></pre>
<p>Questi sono i numeri per gli <code>assert</code>:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, randgauss_ar(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 1.7291105054318905
2: 2.4952592495828867
3: 2.009022830054164
4: 0.6520544346421957
5: 1.318840131163597
</code></pre>
<p>Questo è l&#39;istogramma:</p>
<pre><code class="julia hljs">histogram([randgauss_ar(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/randgauss_ar_hist.svg" alt="">
<h2 id=esercizio_101 ><a href="#esercizio_101" class=header-anchor >Esercizio 10.1</a></h2>
<p>L&#39;esercizio è molto semplice da implementare, ma richiede comunque una certa attenzione: bisogna studiare infatti molti casi &#40;ben 12 istogrammi&#41;, e questo richiede molto ordine e pulizia&#33; Imparare a scrivere codice ordinato è importante soprattutto per il giorno dell&#39;esame: capita spesso che nei temi d&#39;esame si chieda di ripetere più volte un calcolo o una simulazione, ed è bene non usare copia-e-incolla ma strutturare il codice usando dei cicli <code>for</code> e implementando funzioni di supporto anziché rendere il <code>main</code> lungo centinaia di righe.</p>
<p>Iniziamo con l&#39;implementazione di un codice che riempia un vettore con i campioni casuali sommati <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> alla volta:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> computesums!(glc::GLC, n, vec)
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> eachindex(vec)
        accum = <span class=hljs-number >0.0</span>
        <span class=hljs-keyword >for</span> k <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:n
            accum += rand(glc)
        <span class=hljs-keyword >end</span>
        vec[i] = accum
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">computesums! (generic function with 1 method)</code></pre>
<p>&#40;in Julia c&#39;è la convenzione di mettere il carattere <code>&#33;</code> alla fine delle funzioni che modificano uno dei loro argomenti: questo è proprio il nostro caso, perché <code>vec</code> viene modificato da <code>computesums&#33;</code>&#41;</p>
<p>Facciamo una prova semplice:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-comment ># Array di *due* elementi</span>
vec = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, <span class=hljs-number >2</span>)
<span class=hljs-comment ># Chiediamo che in ogni elemento vengano sommati *cinque*</span>
<span class=hljs-comment ># numeri. Quindi ogni elemento di `vec` sarà un numero</span>
<span class=hljs-comment ># casuale nell&#x27;intervallo 0…5.</span>
computesums!(glc, <span class=hljs-number >5</span>, vec)
println(<span class=hljs-string >&quot;vec[1] = &quot;</span>, vec[<span class=hljs-number >1</span>])
println(<span class=hljs-string >&quot;vec[2] = &quot;</span>, vec[<span class=hljs-number >2</span>])</code></pre><pre><code class="plaintext hljs">vec[1] = 1.7307902472093701
vec[2] = 1.7124183257110417
</code></pre>
<p>Potete usare questi numeri in un <code>assert</code> per verificare la vostra implementazione di <code>compute_sums</code> &#40;mettete pure tutto nello stesso file del <code>main</code>&#41;:</p>
<pre><code class="cpp hljs"><span class=hljs-function ><span class=hljs-type >void</span> <span class=hljs-title >test_compute_sums</span><span class=hljs-params >()</span> </span>{
  <span class=hljs-function >std::vector&lt;<span class=hljs-type >double</span>&gt; <span class=hljs-title >vec</span><span class=hljs-params >(<span class=hljs-number >2</span>)</span></span>;  <span class=hljs-comment >// Attenzione, parentesi *tonde* qui!</span>

  RandomGen rng{<span class=hljs-number >1</span>};
  <span class=hljs-built_in >compute_sums</span>(rng, <span class=hljs-number >5</span>, vec);
  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(vec[<span class=hljs-number >0</span>], <span class=hljs-number >1.7307902472093701</span>));
  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(vec[<span class=hljs-number >1</span>], <span class=hljs-number >1.7124183257110417</span>));
  cerr &lt;&lt; <span class=hljs-string >&quot;compute_sums() is correct, hurrah! 🥳\n&quot;</span>;
}</code></pre>
<p>Ora ci occorre invocare questa funzione più volte facendo variare <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> da 1 a 12, e producendo un istogramma ogni volta.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
vec = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, <span class=hljs-number >100_000</span>)

list_of_N = <span class=hljs-number >1</span>:<span class=hljs-number >12</span>
list_of_histograms = []
list_of_sigmas = <span class=hljs-built_in >Float64</span>[]
<span class=hljs-keyword >for</span> n <span class=hljs-keyword >in</span> list_of_N
    computesums!(glc, n, vec)
    push!(list_of_histograms, histogram(vec, bins = <span class=hljs-number >20</span>, title = <span class=hljs-string >&quot;N = <span class=hljs-variable >$n</span>&quot;</span>))
    push!(list_of_sigmas, std(vec))
<span class=hljs-keyword >end</span>
plot(
    list_of_histograms...,
    layout = (<span class=hljs-number >3</span>, <span class=hljs-number >4</span>),
    size = (<span class=hljs-number >900</span>, <span class=hljs-number >600</span>),
    legend = <span class=hljs-literal >false</span>,
)</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/es10_1_histogram.svg" alt="">
<p>Notate che, grazie alla definizione della funzione <code>computesums&#33;</code>, il ciclo <code>for</code> è stato ridotto ad appena tre righe. Inoltre proprio l&#39;uso del <code>for</code> ha evitato quegli orribili copia-e-incolla che spesso i docenti trovano nelle correzioni degli esami scritti.</p>
<p>Il seguente è un esempio di come <strong>non</strong> implementare questo esercizio; è un vero esercizio, consegnato da uno studente pochi anni fa. È una vera e propria “galleria degli orrori”&#33;</p>
<pre><code class="cpp hljs"><span class=hljs-comment >// 👿 NON BASATEVI SU QUESTO CODICE! 👿</span>

<span class=hljs-function >std::vector&lt;<span class=hljs-type >double</span>&gt; <span class=hljs-title >vec</span><span class=hljs-params >(<span class=hljs-number >100&#x27;000</span>)</span></span>;

<span class=hljs-comment >// Aargh! Qui scrive di nuovo il numero 100&#x27;000 anziché usare `ssize(vec)`:</span>
<span class=hljs-comment >// cosa succede se poi durante l&#x27;esame voleva usare un numero minore</span>
<span class=hljs-comment >// per risparmiare tempo? Deve cambiare tutte le occorrenze!</span>
<span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> k{}; k &lt; <span class=hljs-number >100&#x27;000</span>; ++k) {
  vec[k] = <span class=hljs-number >0.0</span>;   <span class=hljs-comment >// Per giunta qui non usa neppure vec.at(k),</span>
                  <span class=hljs-comment >// quindi se riduce il numero 100&#x27;000 nella</span>
                  <span class=hljs-comment >// definizione di `vec` ma non nel ciclo `for`,</span>
                  <span class=hljs-comment >// qui poteva avere un “segmentation fault”!</span>
  <span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> i{}; i &lt; <span class=hljs-number >1</span>; ++i)
    vec[k] += rand.<span class=hljs-built_in >Unif</span>(<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>);
}

<span class=hljs-comment >// Ok, invece che fare una sola figura con 12 grafici sceglie di</span>
<span class=hljs-comment >// creare 12 file PNG distinti… è più faticoso però poi</span>
<span class=hljs-comment >// controllare i risultati e confrontare gli istogrammi!</span>
Gnuplot plt1{};
plt<span class=hljs-number >1.</span><span class=hljs-built_in >redirect_to_svg</span>(<span class=hljs-string >&quot;n1.png&quot;</span>);
plt<span class=hljs-number >1.</span><span class=hljs-built_in >histogram</span>(vec, <span class=hljs-number >20</span>, <span class=hljs-string >&quot;N = 1&quot;</span>);
plt<span class=hljs-number >1.</span><span class=hljs-built_in >show</span>();

<span class=hljs-comment >// Caso con n = 2</span>

<span class=hljs-comment >// NOOOO! Tutto quanto segue è un copia-e-incolla del codice sopra!</span>
<span class=hljs-comment >// Terribile!</span>
<span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> k{}; k &lt; <span class=hljs-number >100&#x27;000</span>; ++k) {
  vec[k] = <span class=hljs-number >0.0</span>;
  <span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> i{}; i &lt; <span class=hljs-number >2</span>; ++i)
    vec[k] += rand.<span class=hljs-built_in >Unif</span>(<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>);
}

Gnuplot plt2{};
plt<span class=hljs-number >3.</span><span class=hljs-built_in >redirect_to_svg</span>(<span class=hljs-string >&quot;n3.png&quot;</span>);
plt<span class=hljs-number >3.</span><span class=hljs-built_in >histogram</span>(vec, <span class=hljs-number >20</span>, <span class=hljs-string >&quot;N = 3&quot;</span>);
plt<span class=hljs-number >3.</span><span class=hljs-built_in >show</span>();

<span class=hljs-comment >// Caso con n = 3</span>
<span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> k{}; k &lt; <span class=hljs-number >100&#x27;000</span>; ++k) {
  vec[k] = <span class=hljs-number >0.0</span>;
  <span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> i{}; i &lt; <span class=hljs-number >3</span>; ++i)
    vec[k] += rand.<span class=hljs-built_in >Unif</span>(<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>);
}

Gnuplot plt3{};
plt<span class=hljs-number >3.</span><span class=hljs-built_in >redirect_to_svg</span>(<span class=hljs-string >&quot;n3.png&quot;</span>);
plt<span class=hljs-number >3.</span><span class=hljs-built_in >histogram</span>(vec, <span class=hljs-number >20</span>, <span class=hljs-string >&quot;N = 3&quot;</span>);
plt<span class=hljs-number >3.</span><span class=hljs-built_in >show</span>();

<span class=hljs-comment >// Il codice continua tutto così… ci siamo capiti!</span>
<span class=hljs-comment >// …</span></code></pre>
<p>Il codice Julia evita di ricorrere ai copia-e-incolla implementando una funzione <code>computesums&#33;</code> e chiamandola più volte all&#39;interno di un ciclo <code>for</code>. Questo approccio è estremamente elegante 😇 e ha molti vantaggi rispetto al disperato copia-e-incolla del malefico esempio 👿:</p>
<ul>
<li><p>Ci mettete meno tempo a scriverlo, e in un esame il tempo è sempre prezioso;</p>

<li><p>Se scegliete l&#39;approccio “copia-e-incolla” 👿 e vi rendete conto di un   errore nel codice che avete appena copiato &#40;ad esempio, una parentesi non chiusa&#41;,   dovete correggerlo dodici volte… ma nel caso 😇 l&#39;errore va corretto una   volta sola&#33; E anche questo è un bel risparmio di tempo.</p>

<li><p>Il codice 😇 è più semplice da leggere, e quindi è più facile individuare   errori &#40;ci sono meno posti in cui il problema potrebbe nascondersi&#41;</p>

<li><p>Se vi rendete conto che il programma ci mette troppo per essere   eseguito, e questo vi è di impiccio perché i risultati non vi   convincono e prevedete di doverlo eseguire molte volte, è   semplice limitare ad esempio i valori di <code>N</code> da esplorare nel   codice 😇, limitandovi ad esempio ai primi 5 casi anziché a   tutti e 12. Nel codice 👿 invece, dovete commentare decine di   righe di codice, col rischio di commentare qualche variabile   importante che vi serve alla fine del programma e che quindi   causa errori di compilazione…</p>

</ul>
<p>Ora creiamo il grafico con l&#39;andamento della deviazione standard &#40;calcolata nell&#39;esempio sopra con la funzione <code>Statistics.std</code>&#41;, memorizzata in <code>list_of_sigmas</code>:</p>
<pre><code class="julia hljs">plot(list_of_N, list_of_sigmas,
     xaxis = :log10, yaxis = :log10, label = <span class=hljs-string >&quot;&quot;</span>,
     xlabel = <span class=hljs-string >&quot;N&quot;</span>, ylabel = <span class=hljs-string >&quot;Standard deviation σ&quot;</span>)</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/es10_1_std.svg" alt="">
<h2 id=esercizio_102 ><a href="#esercizio_102" class=header-anchor >Esercizio 10.2</a></h2>
<p>Questa è una semplice implementazione dell&#39;integrale della media:</p>
<pre><code class="julia hljs"><span class=hljs-string >&quot;&quot;&quot;
    intmean(glc::GLC, fn, a, b, N)

Evaluate the integral of `fn(x)` in the interval ``[a, b]``
using the mean method with ``N`` points.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> intmean(glc::GLC, fn, a, b, N)
    (b - a) * sum([fn(rand(glc, a, b)) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N]) / N
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">intmean</code></pre>
<p>L&#39;integrale <em>hit-or-miss</em> è solo lievemente più complicato:</p>
<pre><code class="julia hljs"><span class=hljs-string >&quot;&quot;&quot;
    inthm(glc::GLC, fn, a, b, fmax, N)

Evaluate the integral of `fn(x)` in the interval ``[a, b]``
using the hit-or-miss method with ``N`` points, assuming that
`fn(x)` assumes values in the range `[0, fmax]`.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> inthm(glc::GLC, fn, a, b, fmax, N)
    hits = <span class=hljs-number >0</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
        x = rand(glc, a, b)
        y = rand(glc, <span class=hljs-number >0</span>, fmax)
        y ≤ fn(x) &amp;&amp; (hits += <span class=hljs-number >1</span>)
    <span class=hljs-keyword >end</span>

    hits / N * (b - a) * fmax
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">inthm</code></pre>
<p>Verifichiamo che il codice compili, e che produca un risultato sensato. Teniamo presente che <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mrow><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn></mrow></msubsup><mi>x</mi><mi>sin</mi><mo>⁡</mo><mi>x</mi><mtext> </mtext><mi mathvariant=normal >d</mi><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\int_0^{\pi/2} x \sin x\,\mathrm{d}x = 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.43872em;vertical-align:-0.35582em;"></span><span class=mop ><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.0829em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span><span class="mord mtight">/2</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.35582em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span>; inoltre, siccome <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>sin</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">x \sin(x)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span> è una funzione limitata in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>, possiamo porre <code>fmax&#61;1</code> nella chiamata a <code>inthm</code>:</p>
<pre><code class="julia hljs">xsinx(x) = x * sin(x)
println(<span class=hljs-string >&quot;Integrale (metodo media):&quot;</span>, intmean(GLC(<span class=hljs-number >1</span>), xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>/<span class=hljs-number >2</span>, <span class=hljs-number >100</span>))
println(<span class=hljs-string >&quot;Integrale (metodo hit-or-miss):&quot;</span>, inthm(GLC(<span class=hljs-number >1</span>), xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>/<span class=hljs-number >2</span>, <span class=hljs-number >1</span>, <span class=hljs-number >100</span>))</code></pre><pre><code class="plaintext hljs">Integrale (metodo media):1.1044291363356546
Integrale (metodo hit-or-miss):0.8325220532012952
</code></pre>
<p>Implementate degli <code>assert</code> che verifichino che ottenete gli stessi risultati nella vostra implementazione C&#43;&#43;. Come già ricordato sopra, fate molta attenzione ad inizializzare il generatore di numeri pseudo-casuali con lo stesso seme &#40;<code>1</code> in questo caso&#41;. Notate anche che il codice sopra usa <strong>due</strong> generatori di numeri casuali: uno per <code>intmean</code> e l&#39;altro per <code>inthm</code>. Se voi invece ne usate uno solo e chiamate <code>intmean</code> e poi <code>inthm</code> passando sempre quello, anche se avete implementato correttamente entrambi i metodi, per <code>intmean</code> lo stesso numero ma per <code>inthm</code> un numero diverso&#33;</p>
<p>Eseguiamo ora il calcolo per 10.000 volte e facciamone l&#39;istogramma: osserviamo che la distribuzione è approssimativamente una Gaussiana, come previsto.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
mean_samples = [intmean(glc, sin, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>, <span class=hljs-number >100</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10_000</span>]
histogram(mean_samples, label=<span class=hljs-string >&quot;Media&quot;</span>)

glc = GLC(<span class=hljs-number >1</span>)  <span class=hljs-comment ># Reset the random generator</span>
mean_hm = [inthm(glc, sin, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>, <span class=hljs-number >1</span>, <span class=hljs-number >100</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10_000</span>]
histogram!(mean_hm, label=<span class=hljs-string >&quot;Hit-or-miss&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/mc_integrals.svg" alt="">
<p>Se l&#39;andamento dell&#39;errore è della forma <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo stretchy=false >(</mo><mi>N</mi><mo stretchy=false >)</mo><mo>=</mo><mi>k</mi><mi mathvariant=normal >/</mi><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">\epsilon(N) = k/\sqrt{N}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϵ</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.176665em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mord >/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9266650000000001em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span>, con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> numero di punti, allora nel nostro caso possiamo stimare <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> immediatamente dalla deviazione standard dei valori in <code>values</code> mediante la formula <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><msqrt><mi>N</mi></msqrt><mo>×</mo><mi>ϵ</mi><mo stretchy=false >(</mo><mi>N</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">k =
\sqrt{N} \times \epsilon(N)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9266650000000001em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.11333499999999996em;"><span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϵ</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mclose >)</span></span></span></span>:</p>
<pre><code class="julia hljs">k_mean = √<span class=hljs-number >100</span> * std(mean_samples)
k_hm = √<span class=hljs-number >100</span> * std(mean_hm)

println(<span class=hljs-string >&quot;K (media) = &quot;</span>, k_mean)
println(<span class=hljs-string >&quot;K (hit-or-miss) = &quot;</span>, k_hm)</code></pre><pre><code class="plaintext hljs">K (media) = 0.9574569402133133
K (hit-or-miss) = 1.4987026076211012
</code></pre>
<p>A questo punto, per rispondere alla domanda del problema, è sufficiente risolvere l&#39;equazione <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.001</mn><mo>=</mo><mi>k</mi><mi mathvariant=normal >/</mi><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">0.001 = k/\sqrt{N}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.001</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.176665em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mord >/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9266650000000001em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span> per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, ossia </p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>N</mi><mo>=</mo><msup><mrow><mo fence=true >(</mo><mfrac><mi>k</mi><mn>0.001</mn></mfrac><mo fence=true >)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N =
\left(\frac{k}{0.001}\right)^2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.604038em;vertical-align:-0.95003em;"></span><span class=minner ><span class=minner ><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.37144em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >0.001</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>
<p>.</p>
<pre><code class="julia hljs">noptim_mean = round(<span class=hljs-built_in >Int</span>, (k_mean/<span class=hljs-number >0.001</span>)^<span class=hljs-number >2</span>)
noptim_hm = round(<span class=hljs-built_in >Int</span>, (k_hm/<span class=hljs-number >0.001</span>)^<span class=hljs-number >2</span>)

println(<span class=hljs-string >&quot;N (media) = &quot;</span>, noptim_mean)
println(<span class=hljs-string >&quot;N (hit-or-miss) = &quot;</span>, noptim_hm)</code></pre><pre><code class="plaintext hljs">N (media) = 916724
N (hit-or-miss) = 2246110
</code></pre>
<p>Per verificare la correttezza del risultato, rifacciamo l&#39;istogramma. Siccome ci vuole molto tempo per ottenere il risultato, verifichiamo il risultato solo nel caso del metodo della media, e per un numero ridotto di realizzazioni &#40;1000 anziché 10.000&#41;:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
values = [intmean(glc, sin, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>, noptim_mean) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >1000</span>]
histogram(values, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/mc_intmean.svg" alt="">
<p>Il risultato è effettivamente corretto:</p>
<pre><code class="julia hljs">std(values)</code></pre><pre><code class="plaintext hljs">0.001000082648024251</code></pre>
<h1 id=lezione_12_simulazione_di_un_esperimento ><a href="#lezione_12_simulazione_di_un_esperimento" class=header-anchor >Lezione 12: Simulazione di un esperimento</a></h1>
<p>L&#39;esercizio di questa lezione è <strong>estremamente</strong> importante, perché le tecniche Monte Carlo sono molto diffuse in fisica. &#40;E inoltre questo è un tipo di tema d&#39;esame che ricorre spesso&#33;&#41;</p>
<p>Ne approfitto anche per mostrarvi un modo di scrivere codice che espliciti le unità di misura e faccia automaticamente un controllo dimensionale. In C&#43;&#43; questo sarebbe fattibile usando la programmazione template, che non è stata però quasi mai usata per lo svolgimento degli esercizi; tenete presente nei vostri futuri progetti che librerie come <a href="https://mpusz.github.io/mp-units/latest/">mp-units</a>, <a href="https://www.boost.org/doc/libs/1_65_0/doc/html/boost_units.html">Boost.units</a>, <a href="https://github.com/bernedom/SI">SI</a>, <a href="https://github.com/nholthaus/units">units</a>, etc. possono essere usate per specificare le unità di misura di variabili e costanti, e per verificarne la consistenza nel proprio codice.</p>
<p>Sfortunatamente, il modo in cui avete scritto programmi in questo semestre fa uso della programmazione <em>object-oriented</em>, che non è adatta per usare questo genere di librerie &#40;e più in generale per il calcolo numerico&#41;, perché avete dichiarato come <code>double</code> tutti i parametri di metodi come <code>Solutore::CercaZeri</code> o <code>Integral::integrate</code>, mentre per usare queste librerie C&#43;&#43; avreste dovuto definire sia <code>Solutore</code> che <code>integral</code> come classi template. Ad esempio:</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >template</span> &lt;<span class=hljs-keyword >typename</span> T, <span class=hljs-keyword >typename</span> Fn&gt;
<span class=hljs-keyword >class</span> <span class="hljs-title class_">Solutore</span> {
<span class=hljs-keyword >public</span>:
  <span class=hljs-built_in >Solutore</span>();

  <span class=hljs-function ><span class=hljs-keyword >virtual</span> T <span class=hljs-title >CercaZeri</span><span class=hljs-params >(T xmin, T xmax, Fn f,
                      T prec = <span class=hljs-number >1e-3</span>, <span class=hljs-type >int</span> nmax = <span class=hljs-number >100</span>)</span> </span>= <span class=hljs-number >0</span>;
};</code></pre>
<p>In questo modo, supponendo di usare la libreria <a href="https://github.com/nholthaus/units">units</a>, avreste potuto poi passare a <code>Solutore::CercaZeri</code> variabili dimensionali, perché il compilatore avrebbe selezionato il tipo <code>T</code> giusto &#40;lunghezza, tempo, etc.&#41;:</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> units::length;
<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> units::time;

Bisezione sol{};

<span class=hljs-comment >// We find the zero of a function f(x), where x is a length</span>
<span class=hljs-keyword >auto</span> result1 = sol.<span class=hljs-built_in >CercaZeri</span>(<span class=hljs-number >0.5</span>_m, <span class=hljs-number >1.5</span>_m, my_function, <span class=hljs-number >1e-4</span>_m);

<span class=hljs-comment >// We find the zero of a function g(t), where t is a time</span>
<span class=hljs-keyword >auto</span> result2 = sol.<span class=hljs-built_in >CercaZeri</span>(<span class=hljs-number >10.0</span>_s, <span class=hljs-number >15.0</span>_s, another_function, <span class=hljs-number >1e-2</span>_s);</code></pre>
<p>Ovviamente, né <code>my_function</code> né <code>another_function</code> sarebbero più state derivate da <code>FunzioneBase</code>, dovendo invece essere funzioni che accettano quantità delle dimensioni giuste.</p>
<p>&#40;In Julia questo tipo di programmazione è naturale perché in un certo senso <em>tutto</em> è un template, e ciò lo rende ideale per il calcolo scientifico. Vedremo meglio questo aspetto nel seminario “jolly” che terrò dopo la sessione di esami per chi è interessato&#41;.</p>
<h2 id=esercizio_120 ><a href="#esercizio_120" class=header-anchor >Esercizio 12.0</a></h2>
<p>Iniziamo con l&#39;importare la libreria <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a>, che implementa le unità di misura che ci servono. Importeremo esplicitamente quelle unità di misura che ci serviranno, perché la libreria di default non ne importa nessuno &#40;simboli come <code>m</code>, <code>s</code>, <code>mm</code>, etc., sono molto usati come nomi di variabili, e sarebbe un disastro se venissero tutti importati senza criterio&#33;&#41;.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Unitful
<span class=hljs-keyword >import</span> Unitful: m, cm, mm, nm, s, °, mrad, <span class=hljs-meta >@u_str</span></code></pre>
<p>I simboli <code>nm</code>, <code>°</code> e <code>mrad</code> sono unità di misura che si possono usare direttamente nelle definizioni, come <code>x &#61; 10nm</code>. La macro <code>@u_str</code>, terminando con <code>_str</code>, indica che può essere usata aggiungendo <code>u</code> dopo le stringhe per specificare le unità di misura. Questo è indispensabile per tipi più complessi dei semplici <code>m</code>, <code>cm</code>, <code>mm</code>, etc., che richiedano espressioni matematiche, come ad esempio i campi elettrici: <code>E &#61; 10u&quot;N/C&quot;</code>.</p>
<p>Definiamo una serie di variabili per le costanti fisiche del problema:</p>
<pre><code class="julia hljs">σ_θ = <span class=hljs-number >0.3</span>mrad;       <span class=hljs-comment ># Avrei potuto scrivere σ_θ = 0.3u&quot;mrad&quot;</span>
θ<span class=hljs-number >0_</span>ref = <span class=hljs-number >90</span>°;        <span class=hljs-comment ># Ugualmente,           θ0_ref = 90u&quot;°&quot;</span>
Aref = <span class=hljs-number >2.7</span>;
Bref = <span class=hljs-number >6e4</span><span class=hljs-string >u&quot;nm^2&quot;</span>;   <span class=hljs-comment ># Qui devo usare `u` perché nm² è troppo complicato</span>
α = <span class=hljs-number >60.0</span>°;
λ<span class=hljs-number >1</span> = <span class=hljs-number >579.1</span>nm;
λ<span class=hljs-number >2</span> = <span class=hljs-number >404.7</span>nm;</code></pre>
<p>La funzione <code>n_cauchy</code> restituisce <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> supponendo vera la formula di Cauchy. La sintassi con un parametro usa i valori di riferimento di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> scritti sopra.</p>
<pre><code class="julia hljs">n_cauchy(λ, A, B) = sqrt(A + B / λ^<span class=hljs-number >2</span>)
n_cauchy(λ) = n_cauchy(λ, Aref, Bref)</code></pre><pre><code class="plaintext hljs">n_cauchy (generic function with 2 methods)</code></pre>
<p>La funzione <code>n</code> invece restituisce <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> in funzione della deviazione misurata <code>δ</code> dal prisma, dove <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> è il suo angolo di apertura &#40;definito sopra&#41;. Siccome la funzione <code>asin</code> &#40;arcoseno&#41; restituisce il valore in radianti, che è scomodo da leggere, definiamo <code>δ</code> in modo che esprima sempre il risultato in gradi: per questo scopo c&#39;è la funzione <code>uconvert</code>, che richiede come primo parametro l&#39;unità di misura di <em>destinazione</em> &#40;nel nostro caso gradi, quindi <code>u&quot;°&quot;</code>&#41;.</p>
<pre><code class="julia hljs">n(δ) = sin((δ + α) / <span class=hljs-number >2</span>) / sin(α / <span class=hljs-number >2</span>)
δ(n) = uconvert(<span class=hljs-string >u&quot;°&quot;</span>, <span class=hljs-number >2</span>asin(n * sin(α / <span class=hljs-number >2</span>)) - α)</code></pre><pre><code class="plaintext hljs">δ (generic function with 1 method)</code></pre>
<p>Queste formule si ricavano banalmente dall&#39;inversione della formula di Cauchy; la funzione <code>A_and_B</code> calcola contemporaneamente <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, ed è stata definita per comodità:</p>
<pre><code class="julia hljs">A(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>) = (λ<span class=hljs-number >2</span>^<span class=hljs-number >2</span> * n(δ<span class=hljs-number >2</span>)^<span class=hljs-number >2</span> - λ<span class=hljs-number >1</span>^<span class=hljs-number >2</span> * n(δ<span class=hljs-number >1</span>)^<span class=hljs-number >2</span>) / (λ<span class=hljs-number >2</span>^<span class=hljs-number >2</span> - λ<span class=hljs-number >1</span>^<span class=hljs-number >2</span>)
B(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>) = (n(δ<span class=hljs-number >2</span>)^<span class=hljs-number >2</span> - n(δ<span class=hljs-number >1</span>)^<span class=hljs-number >2</span>) / (<span class=hljs-number >1</span>/λ<span class=hljs-number >2</span>^<span class=hljs-number >2</span> - <span class=hljs-number >1</span>/λ<span class=hljs-number >1</span>^<span class=hljs-number >2</span>)
A_and_B(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>) = (A(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>), B(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>))</code></pre><pre><code class="plaintext hljs">A_and_B (generic function with 1 method)</code></pre>
<p>Calcoliamo allora i valori di riferimento di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy=false >(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo stretchy=false >)</mo><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n(\lambda_1) = n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">λ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy=false >(</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy=false >)</mo><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n(\lambda_2) = n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">λ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, supponendo veri i valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> scritti sopra r&#40;<code>A_ref</code> e <code>B_ref</code>&#41;:</p>
<pre><code class="julia hljs">n1_ref, n2_ref = n_cauchy(λ<span class=hljs-number >1</span>), n_cauchy(λ<span class=hljs-number >2</span>)</code></pre><pre><code class="plaintext hljs">(1.6967362539886182, 1.751096919705952)</code></pre>
<p>Da <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> calcoliamo quanto aspettarci per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\delta_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\delta_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:</p>
<pre><code class="julia hljs">δ<span class=hljs-number >1_</span>ref, δ<span class=hljs-number >2_</span>ref = δ(n1_ref), δ(n2_ref)</code></pre><pre><code class="plaintext hljs">(56.06923804490447°, 62.21990453258211°)</code></pre>
<p>Il vostro codice probabilmente stamperà angoli in radianti &#40;è la convenzione di <code>asin</code> in C&#43;&#43;&#41;, quindi convertiamo i valori sopra in modo che possiate confrontarli col risultato del vostro programma:</p>
<pre><code class="julia hljs">println(<span class=hljs-string >&quot;δ1_ref = &quot;</span>, uconvert(<span class=hljs-string >u&quot;rad&quot;</span>, δ<span class=hljs-number >1_</span>ref))
println(<span class=hljs-string >&quot;δ2_ref = &quot;</span>, uconvert(<span class=hljs-string >u&quot;rad&quot;</span>, δ<span class=hljs-number >2_</span>ref))</code></pre><pre><code class="plaintext hljs">δ1_ref = 0.9785928129680513 rad
δ2_ref = 1.0859421943701013 rad
</code></pre>
<p>A questo punto possiamo simulare l&#39;esperimento. La simulazione della misura di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\delta_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\delta_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> va fatta usando l&#39;approssimazione Gaussiana con i valori medi <code>δ1_ref</code> e <code>δ2_ref</code>, e la deviazione standard <code>σ_θ</code> data dal testo dell&#39;esercizio:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simulate_experiment(glc, nsim)
    n1_simul = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, nsim)
    n2_simul = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, nsim)

    A_simul = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, nsim)
    <span class=hljs-comment ># Here I create an array of values whose measurement unit</span>
    <span class=hljs-comment ># must be the same as `Bref`</span>
    B_simul = <span class=hljs-built_in >Array</span>{typeof(Bref)}(<span class=hljs-literal >undef</span>, nsim)

    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:nsim
        θ<span class=hljs-number >0</span> = randgauss(glc, θ<span class=hljs-number >0_</span>ref, σ_θ)
        θ<span class=hljs-number >1</span> = randgauss(glc, θ<span class=hljs-number >0_</span>ref + δ<span class=hljs-number >1_</span>ref, σ_θ)
        θ<span class=hljs-number >2</span> = randgauss(glc, θ<span class=hljs-number >0_</span>ref + δ<span class=hljs-number >2_</span>ref, σ_θ)
        δ<span class=hljs-number >1</span>, δ<span class=hljs-number >2</span> = θ<span class=hljs-number >1</span> - θ<span class=hljs-number >0</span>, θ<span class=hljs-number >2</span> - θ<span class=hljs-number >0</span>
        n1, n2 = n(δ<span class=hljs-number >1</span>), n(δ<span class=hljs-number >2</span>)
        a, b = A_and_B(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>)

        n1_simul[i] = n1
        n2_simul[i] = n2

        A_simul[i] = a
        B_simul[i] = b
    <span class=hljs-keyword >end</span>

    (n1_simul, n2_simul, A_simul, B_simul)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">simulate_experiment (generic function with 1 method)</code></pre>
<p>Ecco i primi 5 valori della simulazione; controllate che siano gli stessi che ottenete voi, facendo attenzione di usare come seme <code>1</code> e che l&#39;ordine in cui chiamate la funzione per generare i numeri casuali sia la stessa del codice sopra:</p>
<ol>
<li><p><em>Prima</em> si genera <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>;</p>

<li><p><em>Poi</em> si generano <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\theta_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>

</ol>
<p>Nel fare i plot qui sotto mi limito a ripetere l&#39;esperimento 1000 volte &#40;il testo richiede 10.000 volte&#41;. I risultati non cambiano molto.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
n1_simul, n2_simul, A_simul, B_simul = simulate_experiment(glc, <span class=hljs-number >1000</span>)

<span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14s %14s %14s %14s\n&quot;</span>, <span class=hljs-string >&quot;n₁&quot;</span>, <span class=hljs-string >&quot;n₂&quot;</span>, <span class=hljs-string >&quot;A&quot;</span>, <span class=hljs-string >&quot;B [nm²]&quot;</span>)
println(repeat(<span class=hljs-string >&#x27;-&#x27;</span>, <span class=hljs-number >62</span>))
<span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    <span class=hljs-comment ># We use scientific notation for B, as it is ≪1. As we want to</span>
    <span class=hljs-comment ># avoid printing units for B (they are already in the table header),</span>
    <span class=hljs-comment ># we just «strip» nm² from it.</span>
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14.6f %14.6f %14.6f %14.6e\n&quot;</span>,
            n1_simul[i], n2_simul[i], A_simul[i], ustrip(<span class=hljs-string >u&quot;nm^2&quot;</span>, B_simul[i]))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">            n₁             n₂              A        B [nm²]
--------------------------------------------------------------
      1.696336       1.751088       2.697376   6.042476e+04
      1.696530       1.751072       2.698717   6.019579e+04
      1.697061       1.751154       2.701963   5.971105e+04
      1.696581       1.750721       2.700224   5.974773e+04
      1.696977       1.751137       2.701460   5.978394e+04
</code></pre>
<pre><code class="julia hljs">histogram([n1_simul, n2_simul],
          label = [<span class=hljs-string >&quot;n₁&quot;</span> <span class=hljs-string >&quot;n₂&quot;</span>],
          layout = (<span class=hljs-number >2</span>, <span class=hljs-number >1</span>));</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/hist_n1_n2.svg" alt="">
<pre><code class="julia hljs">scatter(n1_simul, n2_simul, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/scatter_n1_n2.svg" alt="">
<p>Il package <code>Statistics</code> di Julia implementa il calcolo della covarianza tra due serie, che è uguale alla correlazione a meno di una normalizzazione. Definiamo quindi la funzione <code>corr</code>, che calcola il coefficiente di correlazione, analogamente a questa; nel vostro codice C&#43;&#43; dovrete invece implementarla usando la formula.</p>
<pre><code class="julia hljs">corr(x, y) = cov(x, y) / (std(x) * std(y))</code></pre><pre><code class="plaintext hljs">corr (generic function with 1 method)</code></pre>
<p>I valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ed <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> sono correlati, perché sono entrambi stati ricavati dalla medesima stima di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<pre><code class="julia hljs">corr(n1_simul, n2_simul)</code></pre><pre><code class="plaintext hljs">0.5141392923977048</code></pre>
<p>Nel fare l&#39;istogramma di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, rimuoviamo le unità di misura da quest&#39;ultimo, perché altrimenti Julia segnalerebbe che <code>A_simul</code> e <code>B_simul</code> sono incompatibili &#40;essendo combinati nella stessa chiamata ad <code>histogram</code>&#41;:</p>
<pre><code class="julia hljs">histogram([A_simul, ustrip.(<span class=hljs-string >u&quot;nm^2&quot;</span>, B_simul)],
          label = [<span class=hljs-string >&quot;A&quot;</span> <span class=hljs-string >&quot;B&quot;</span>],
          layout = (<span class=hljs-number >2</span>, <span class=hljs-number >1</span>))</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/hist_A_B.svg" alt="">
<p>Facciamo anche un grafico X-Y</p>
<pre><code class="julia hljs">scatter(A_simul, B_simul, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/scatter_A_B.svg" alt="">
<p>Ricalcoliamo qui i coefficienti di correlazione nel caso in cui l&#39;esperimento sia rifatto 10.000 volte. Notate che creo di nuovo un generatore di numeri casuali.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
(n1_simul, n2_simul, A_simul, B_simul) = simulate_experiment(glc, <span class=hljs-number >10_000</span>)
println(<span class=hljs-string >&quot;Correlazione tra n1 e n2: &quot;</span>, corr(n1_simul, n2_simul))
println(<span class=hljs-string >&quot;Correlazione tra A e B: &quot;</span>, corr(A_simul, B_simul))</code></pre><pre><code class="plaintext hljs">Correlazione tra n1 e n2: 0.49893100194096607
Correlazione tra A e B: -0.8706760061112551
</code></pre>
<h2 id=esercizio_121_attrito_viscoso_facoltativo ><a href="#esercizio_121_attrito_viscoso_facoltativo" class=header-anchor >Esercizio 12.1 — Attrito viscoso &#40;facoltativo&#41;</a></h2>
<p>L&#39;esercizio 12.1 è preso da un vecchio tema d&#39;esame, e va svolto in modo molto simile al precedente. Si tratta di misurare il coefficiente di viscosità <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> partendo dalla velocità di caduta di una sferetta di metallo all&#39;interno di un cilindro pieno di glicerina, tramite la formula </p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msub><mi>v</mi><mi>L</mi></msub><mo>=</mo><mfrac><mrow><mn>2</mn><msup><mi>R</mi><mn>2</mn></msup></mrow><mrow><mn>9</mn><mi>η</mi></mrow></mfrac><mo stretchy=false >(</mo><mi>ρ</mi><mo>−</mo><msub><mi>ρ</mi><mn>0</mn></msub><mo stretchy=false >)</mo><mi>g</mi><mo>=</mo><mfrac><mrow><mi mathvariant=normal >Δ</mi><mi>x</mi></mrow><mrow><mi mathvariant=normal >Δ</mi><mi>t</mi></mrow></mfrac><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex"> v_L =
\frac{2R^2}{9\eta}(\rho - \rho_0) g = \frac{\Delta x}{\Delta t}, </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.371548em;vertical-align:-0.8804400000000001em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.491108em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >9</span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >2</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mopen >(</span><span class="mord mathnormal">ρ</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">ρ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.04633em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.36033em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >Δ</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >Δ</span><span class="mord mathnormal">x</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mpunct >,</span></span></span></span></span>
<p>dove <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\Delta x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Δ</span><span class="mord mathnormal">x</span></span></span></span> è la lunghezza del tratto percorso in caduta dalla sferetta e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Δ</span><span class="mord mathnormal">t</span></span></span></span> il tempo impiegato. La relazione si inverte facilmente per dare </p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>η</mi><mo>=</mo><mfrac><mrow><mn>2</mn><msup><mi>R</mi><mn>2</mn></msup><mtext> </mtext><mi>g</mi><mtext> </mtext><mi mathvariant=normal >Δ</mi><mi>t</mi></mrow><mrow><mn>9</mn><mtext> </mtext><mi mathvariant=normal >Δ</mi><mi>x</mi></mrow></mfrac><mo stretchy=false >(</mo><mi>ρ</mi><mo>−</mo><msub><mi>ρ</mi><mn>0</mn></msub><mo stretchy=false >)</mo><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex">
\eta = \frac{2R^2\,g\,\Delta t}{9\,\Delta x}(\rho - \rho_0), </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.177108em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.491108em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >9</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >Δ</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >2</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >Δ</span><span class="mord mathnormal">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mopen >(</span><span class="mord mathnormal">ρ</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">ρ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mpunct >,</span></span></span></span></span>
<p>dove le quantità misurate in ognuno degli esperimenti Monte Carlo sono <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\Delta x
= x_1 - x_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Δ</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.73333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Δ</span><span class="mord mathnormal">t</span></span></span></span>.</p>
<p>Definiamo le costanti numeriche del problema, usando ancora Unitful.jl:</p>
<pre><code class="julia hljs">δt, δx, δR = <span class=hljs-number >0.01</span>s, <span class=hljs-number >0.001</span>m, <span class=hljs-number >0.0001</span>m;
ρ, ρ<span class=hljs-number >0</span> = <span class=hljs-number >2700.0</span><span class=hljs-string >u&quot;kg/m^3&quot;</span>, <span class=hljs-number >1250.0</span><span class=hljs-string >u&quot;kg/m^3&quot;</span>;
g = <span class=hljs-number >9.81</span><span class=hljs-string >u&quot;m/s^2&quot;</span>;
η_true = <span class=hljs-number >0.83</span><span class=hljs-string >u&quot;kg/m/s&quot;</span>;
R_true = [<span class=hljs-number >0.01</span>m, <span class=hljs-number >0.005</span>m];
x0 = <span class=hljs-number >20</span>cm;
x1 = <span class=hljs-number >60</span>cm;
Δx_true = x1 - x0;</code></pre>
<p>Definiamo anche alcune relazioni matematiche.</p>
<pre><code class="julia hljs">v_L(R, η) = <span class=hljs-number >2</span>R^<span class=hljs-number >2</span> / (<span class=hljs-number >9</span>η) * (ρ - ρ<span class=hljs-number >0</span>) * g;
Δt(R, Δx, η) = Δx / v_L(R, η);
Δt_true = [Δt(R, Δx_true, η_true) <span class=hljs-keyword >for</span> R <span class=hljs-keyword >in</span> R_true];
η(R, Δt, Δx) = <span class=hljs-number >2</span>R^<span class=hljs-number >2</span> * g * Δt / (<span class=hljs-number >9</span>Δx) * (ρ - ρ<span class=hljs-number >0</span>);</code></pre>
<p>Definiamo ora la funzione <code>simulate</code>, che effettua <em>due</em> esperimenti: uno con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0.01</mn><mtext> </mtext><mtext>m</mtext></mrow><annotation encoding="application/x-tex">R = 0.01\,\text{m}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.01</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >m</span></span></span></span></span> e l&#39;altro con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0.005</mn><mtext> </mtext><mtext>m</mtext></mrow><annotation encoding="application/x-tex">R = 0.005\,\text{m}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.005</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >m</span></span></span></span></span>.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simulate(glc::GLC, δx, δt, δR)
    <span class=hljs-comment ># Misura dell&#x27;altezza iniziale</span>
    cur_x0 = randgauss(glc, x0, δx)
    <span class=hljs-comment ># Misura dell&#x27;altezza finale</span>
    cur_x1 = randgauss(glc, x1, δx)

    <span class=hljs-comment ># Questo array di 2 elementi conterrà le due stime di η</span>
    <span class=hljs-comment ># (corrispondenti ai due possibili raggi della sferetta)</span>
    estimated_η = zeros(typeof(η_true), <span class=hljs-number >2</span>)
    <span class=hljs-keyword >for</span> case <span class=hljs-keyword >in</span> [<span class=hljs-number >1</span>, <span class=hljs-number >2</span>]
        <span class=hljs-comment ># Misura delle dimensioni della sferetta</span>
        cur_R = randgauss(glc, R_true[case], δR)
        cur_Δx = cur_x1 - cur_x0

        <span class=hljs-comment ># Misura del tempo necessario per cadere da cur_x0 a cur_x1</span>
        cur_Δt = randgauss(glc, Δt_true[case], δt)

        <span class=hljs-comment ># Stima di η</span>
        estimated_η[case] = η(cur_R, cur_Δt, cur_Δx)
    <span class=hljs-keyword >end</span>

    estimated_η
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">simulate (generic function with 1 method)</code></pre>
<p>Eseguiamo ora 1000 simulazioni e facciamo l&#39;istogramma della stima di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> per i due raggi della sferetta.</p>
<pre><code class="julia hljs">N = <span class=hljs-number >1_000</span>
glc = GLC(<span class=hljs-number >1</span>)

η<span class=hljs-number >1</span> = <span class=hljs-built_in >Array</span>{typeof(η_true)}(<span class=hljs-literal >undef</span>, N)
η<span class=hljs-number >2</span> = <span class=hljs-built_in >Array</span>{typeof(η_true)}(<span class=hljs-literal >undef</span>, N)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (η<span class=hljs-number >1</span>[i], η<span class=hljs-number >2</span>[i]) = simulate(glc, δx, δt, δR)
<span class=hljs-keyword >end</span>

histogram(η<span class=hljs-number >2</span>, label=<span class=hljs-string >&quot;R = <span class=hljs-subst >$(R_true[<span class=hljs-number >2</span>])</span>&quot;</span>)
histogram!(η<span class=hljs-number >1</span>, label=<span class=hljs-string >&quot;R = <span class=hljs-subst >$(R_true[<span class=hljs-number >1</span>])</span>&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/hist_eta1_eta2.svg" alt="">
<p>Si tratta ora di stimare le incertezze di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> al variare degli errori considerati. Notate che per usare <code>round</code> con quantità associate ad unità di misura è necessario specificare l&#39;unità di misura usata per arrotondare: con 4 cifre, il valore <code>1 m</code> potrebbe essere scritto come <code>1.0000 m</code> oppure <code>100.0000 cm</code>&#33;</p>
<pre><code class="julia hljs"><span class=hljs-comment ># In η1 ed η2 abbiamo già le stime di η considerando tutti</span>
<span class=hljs-comment ># e tre gli errori</span>
println(<span class=hljs-string >&quot;Tutti gli errori: δη(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))

<span class=hljs-comment ># Ora dobbiamo eseguire di nuovo N esperimenti, assumendo che</span>
<span class=hljs-comment ># l&#x27;errore sia presente in una sola delle tre quantità</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (η<span class=hljs-number >1</span>[i], η<span class=hljs-number >2</span>[i]) = simulate(glc, <span class=hljs-number >0.0</span>m, <span class=hljs-number >0.0</span>s, δR)
<span class=hljs-keyword >end</span>
println(<span class=hljs-string >&quot;Solo δR:          δη(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))

<span class=hljs-comment ># Idem</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (η<span class=hljs-number >1</span>[i], η<span class=hljs-number >2</span>[i]) = simulate(glc, <span class=hljs-number >0.0</span>m, δt, <span class=hljs-number >0.0</span>m)
<span class=hljs-keyword >end</span>
println(<span class=hljs-string >&quot;Solo δt:          δη(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))

<span class=hljs-comment ># Idem</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (η<span class=hljs-number >1</span>[i], η<span class=hljs-number >2</span>[i]) = simulate(glc, δx, <span class=hljs-number >0.0</span>s, <span class=hljs-number >0.0</span>m)
<span class=hljs-keyword >end</span>
println(<span class=hljs-string >&quot;Solo δx:          δη(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))</code></pre><pre><code class="plaintext hljs">Tutti gli errori: δη(R1) = 0.0192 kg m^-1 s^-1
                    (R2) = 0.0333 kg m^-1 s^-1
Solo δR:          δη(R1) = 0.0172 kg m^-1 s^-1
                    (R2) = 0.034 kg m^-1 s^-1
Solo δt:          δη(R1) = 0.0083 kg m^-1 s^-1
                    (R2) = 0.002 kg m^-1 s^-1
Solo δx:          δη(R1) = 0.003 kg m^-1 s^-1
                    (R2) = 0.003 kg m^-1 s^-1
</code></pre>

<div class=page-foot >
  <div class=copyright >
    &copy; Maurizio Tomasi. Last modified: December 03, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>