<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/tnds-notebooks/libs/katex/katex.min.css"> <link rel=stylesheet  href="/tnds-notebooks/libs/highlight/github.min.css"> <link rel=stylesheet  href="/tnds-notebooks/css/franklin.css"> <link rel=stylesheet  href="/tnds-notebooks/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/tnds-notebooks/assets/favicon.png"> <title>Lezioni 10 e 11</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <h1><a href="/tnds-notebooks/">TNDS</a></h1> <p class=lead >Prof. M.&nbsp;Tomasi</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/tnds-notebooks/">Home</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione07/">Lezione 07</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione08/">Lezione 08</a> <a class="sidebar-nav-item active" href="/tnds-notebooks/lezione10/">Lezioni 10 e 11</a> </nav> <p>&copy; Maurizio Tomasi.</p> </div> </div> <div class="content container"> <div class=franklin-content > <p>Dal momento che la lezione 11 richiede di impiegare i codici sviluppati nella lezione 10, presento gli esercizi delle due lezioni in un&#39;unica pagina.</p> <p><div class=franklin-toc ><ol><li><a href="#lezione_10">Lezione 10</a><ol><li><a href="#esercizio_101">Esercizio 10.1</a><ol><li><a href="#generatore_lineare_congruenziale">Generatore Lineare Congruenziale</a><li><a href="#distribuzione_esponenziale">Distribuzione esponenziale</a><li><a href="#distribuzione_gaussiana">Distribuzione Gaussiana</a><li><a href="#distribuzione_gaussiana_con_metodo_accept-reject">Distribuzione Gaussiana con metodo Accept-Reject</a></ol><li><a href="#esercizio_102">Esercizio 10.2</a></ol><li><a href="#lezione_11_metodi_monte_carlo">Lezione 11: Metodi Monte Carlo</a><ol><li><a href="#esercizio_110">Esercizio 11.0</a><li><a href="#esercizio_111">Esercizio 11.1</a></ol></ol></div> </p> <h1 id=metodi_monte_carlo_lezioni_10_e_11 ><a href="#metodi_monte_carlo_lezioni_10_e_11" class=header-anchor >Metodi Monte Carlo &#40;Lezioni 10 e 11&#41;</a></h1> <h2 id=lezione_10 ><a href="#lezione_10" class=header-anchor >Lezione 10</a></h2> <p>Iniziamo importando i pacchetti che ci serviranno.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Printf
<span class=hljs-keyword >using</span> Plots
<span class=hljs-keyword >using</span> Statistics</code></pre> <h3 id=esercizio_101 ><a href="#esercizio_101" class=header-anchor >Esercizio 10.1</a></h3> <p>In Julia non esiste il concetto di «classe», ma esistono le <code>struct</code> che funzionano in modo concettualmente simile. Non permettono di associare metodi, tranne eventualmente un semplice costruttore, e tutti i campi sono pubblici di default.</p> <p>Definiamo una classe <code>GLC</code> che sia equivalente alla classe <code>Random</code> che vi viene richiesto di implementare in C&#43;&#43;.</p> <h4 id=generatore_lineare_congruenziale ><a href="#generatore_lineare_congruenziale" class=header-anchor >Generatore Lineare Congruenziale</a></h4> <pre><code class="julia hljs"><span class=hljs-keyword >mutable struct</span> GLC
    a::<span class=hljs-built_in >UInt64</span>
    c::<span class=hljs-built_in >UInt64</span>
    m::<span class=hljs-built_in >UInt64</span>
    seed::<span class=hljs-built_in >UInt64</span>

    GLC(myseed) = new(<span class=hljs-number >1664525</span>, <span class=hljs-number >1013904223</span>, <span class=hljs-number >1</span> &lt;&lt; <span class=hljs-number >31</span>, myseed)
<span class=hljs-keyword >end</span></code></pre> <p>Definiamo ora una funzione <code>rand</code> che restituisca un numero casuale floating-point compreso in un intervallo:</p> <pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >&quot;&quot;&quot;
    rand(glc::GLC, xmin, xmax)

Return a pseudo-random number uniformly distributed in the
interval [xmin, xmax).
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> rand(glc::GLC, xmin, xmax)
    glc.seed = (glc.a * glc.seed + glc.c) % glc.m
    xmin + (xmax - xmin) * glc.seed / glc.m
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">rand</code></pre>
<p>È molto comodo avere anche una funzione <code>rand</code> che usi l&#39;intervallo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>.</p>
<pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >&quot;&quot;&quot;
    rand(glc::GLC)

Return a pseudo-random number uniformly distributed in the
interval [0, 1).
&quot;&quot;&quot;</span>
rand(glc::GLC) = rand(glc, <span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>)</code></pre><pre><code class="plaintext hljs">rand</code></pre>
<p>Le funzioni definite sopra forniscono una guida, definita dalla macro <code>@doc</code> e invocabile dalla REPL col carattere <code>?</code> seguito dal nome della funzione:</p>
<pre><code class="julia hljs">julia&gt; ?randgauss</code></pre>
<p>Questi sono i numeri che dovreste aspettarvi se avete implementato bene il vostro codice &#40;notate che i numeri cambiano se usate un seed diverso&#33;&#41;.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, rand(glc))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 0.47291105054318905
2: 0.7385413474403322
3: 0.008484064601361752
4: 0.40976652735844254
5: 0.10108725726604462
</code></pre>
<p>Preoccupatevi quindi di creare una serie di <code>assert</code> nel vostro codice C&#43;&#43; che verifichino che ottenete gli stessi valori se partite dallo stesso seme &#40;<code>1</code>&#41;, possibilmente in una funzione <code>test_random_numbers&#40;&#41;</code> invocata all&#39;inizio del vostro <code>main</code>.</p>
<p>Quando si implementano numeri pseudo-casuali, è sempre bene farsi un&#39;idea della distribuzione dei valori. Disegnamo quindi l&#39;istogramma della distribuzione di un gran numero di campioni, e verifichiamo che siano uniformemente distribuiti nell&#39;intervallo &#91;0, 1&#41;.</p>
<pre><code class="julia hljs">histogram([rand(glc) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/rand_hist.svg" alt="">
<h4 id=distribuzione_esponenziale ><a href="#distribuzione_esponenziale" class=header-anchor >Distribuzione esponenziale</a></h4>
<p>Trattandosi di una formula semplice, in Julia si può definire <code>randexp</code> con una sola riga di codice:</p>
<pre><code class="julia hljs"><span class=hljs-string >&quot;&quot;&quot;
    randexp(glc::GLC)

Return a positive pseudo-random number distributed with a
probability density ``p(x) = λ e^{-λ x}``.
&quot;&quot;&quot;</span>
randexp(glc::GLC, λ) = -log(<span class=hljs-number >1</span> - rand(glc)) / λ</code></pre><pre><code class="plaintext hljs">randexp</code></pre>
<p>Questi sono i numeri per i vostri <code>assert</code>:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, randexp(glc, <span class=hljs-number >1</span>))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 0.6403859601352556
2: 1.3414791243855002
3: 0.008520259140710315
4: 0.5272371040158115
5: 0.10656930958385337
</code></pre>
<p>Questo è l&#39;istogramma</p>
<pre><code class="julia hljs">histogram([randexp(glc, <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/randexp_hist.svg" alt="">
<h4 id=distribuzione_gaussiana ><a href="#distribuzione_gaussiana" class=header-anchor >Distribuzione Gaussiana</a></h4>
<pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >raw&quot;&quot;&quot;
    randgauss(glc::GLC, μ, σ)

Return a pseudo-random number distributed with a probability
density ``p(x) = \frac{1}{\sqrt{2πσ^2}}
\exp\left(-\frac{(x - μ)^2}{2σ^2}\right)``, using the
Box-Müller algorithm.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> randgauss(glc::GLC, μ, σ)
    s = rand(glc)
    t = rand(glc)
    x = sqrt(-<span class=hljs-number >2</span>log(<span class=hljs-number >1</span> - s)) * cos(<span class=hljs-number >2</span><span class=hljs-literal >π</span> * t)
    μ + σ * x
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">randgauss</code></pre>
<p>Questi sono i numeri per i vostri <code>assert</code>:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, randgauss(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 1.9185906933235062
2: 1.8898847197814346
3: 1.9682233298032183
4: 2.960947466486181
5: 1.9538792463229713
</code></pre>
<p>Questo è l&#39;istogramma:</p>
<pre><code class="julia hljs">histogram([randgauss(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/randgauss_hist.svg" alt="">
<h4 id=distribuzione_gaussiana_con_metodo_accept-reject ><a href="#distribuzione_gaussiana_con_metodo_accept-reject" class=header-anchor >Distribuzione Gaussiana con metodo Accept-Reject</a></h4>
<pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >raw&quot;&quot;&quot;
    randgauss_ar(glc::GLC, μ, σ)

Return a pseudo-random number distributed with a probability
density ``p(x) = \frac1{\sqrt{2πσ^2}}
\exp\left(-\frac{(x - μ)^2}{2σ^2}\right)``, using the
accept-reject algorithm.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> randgauss_ar(glc::GLC, μ, σ)
    <span class=hljs-keyword >while</span> <span class=hljs-literal >true</span>  <span class=hljs-comment ># Loop forever</span>
        x = rand(glc, -<span class=hljs-number >5.</span>, <span class=hljs-number >5.</span>)
        y = rand(glc)
        g = exp(-x^<span class=hljs-number >2</span> / <span class=hljs-number >2</span>)
        y ≤ g &amp;&amp; <span class=hljs-keyword >return</span> μ + x * σ
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">randgauss_ar</code></pre>
<p>Questi sono i numeri per gli <code>assert</code>:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, randgauss_ar(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 1.7291105054318905
2: 2.4952592495828867
3: 2.009022830054164
4: 0.6520544346421957
5: 1.318840131163597
</code></pre>
<p>Questo è l&#39;istogramma:</p>
<pre><code class="julia hljs">histogram([randgauss_ar(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/randgauss_ar_hist.svg" alt="">
<h3 id=esercizio_102 ><a href="#esercizio_102" class=header-anchor >Esercizio 10.2</a></h3>
<p>Questa è una semplice implementazione dell&#39;integrale della media:</p>
<pre><code class="julia hljs"><span class=hljs-string >&quot;&quot;&quot;
    intmean(glc::GLC, fn, a, b, N)

Evaluate the integral of `fn(x)` in the interval ``[a, b]``
using the mean method with ``N`` points.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> intmean(glc::GLC, fn, a, b, N)
    (b - a) * sum([fn(rand(glc, a, b)) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N]) / N
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">intmean</code></pre>
<p>L&#39;integrale <em>hit-or-miss</em> è solo lievemente più complicato:</p>
<pre><code class="julia hljs"><span class=hljs-string >&quot;&quot;&quot;
    inthm(glc::GLC, fn, a, b, fmax, N)

Evaluate the integral of `fn(x)` in the interval ``[a, b]``
using the hit-or-miss method with ``N`` points, assuming that
`fn(x)` assumes values in the range `[0, fmax]`.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> inthm(glc::GLC, fn, a, b, fmax, N)
    hits = <span class=hljs-number >0</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
        x = rand(glc, a, b)
        y = rand(glc, <span class=hljs-number >0</span>, fmax)
        y ≤ fn(x) &amp;&amp; (hits += <span class=hljs-number >1</span>)
    <span class=hljs-keyword >end</span>

    hits / N * (b - a) * fmax
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">inthm</code></pre>
<p>Verifichiamo che il codice compili, e che produca un risultato sensato. Teniamo presente che <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>0</mn><mi>π</mi></msubsup><mi>sin</mi><mo>⁡</mo><mi>x</mi><mtext> </mtext><mi mathvariant=normal >d</mi><mi>x</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\int_0^\pi \sin x\,\mathrm{d}x = 2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.215112em;vertical-align:-0.35582em;"></span><span class=mop ><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.8592920000000001em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">π</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.35582em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >2</span></span></span></span>; inoltre, siccome <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\sin(x)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span> è una funzione limitata in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>, possiamo porre <code>fmax&#61;1</code> nella chiamata a <code>inthm</code>:</p>
<pre><code class="julia hljs">println(<span class=hljs-string >&quot;Integrale (metodo media):&quot;</span>, intmean(GLC(<span class=hljs-number >1</span>), sin, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>, <span class=hljs-number >100</span>))
println(<span class=hljs-string >&quot;Integrale (metodo hit-or-miss):&quot;</span>, inthm(GLC(<span class=hljs-number >1</span>), sin, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>, <span class=hljs-number >1</span>, <span class=hljs-number >100</span>))</code></pre><pre><code class="plaintext hljs">Integrale (metodo media):1.8715046084621125
Integrale (metodo hit-or-miss):1.9477874452256718
</code></pre>
<p>Implementate degli <code>assert</code> che verifichino che ottenete gli stessi risultati nella vostra implementazione C&#43;&#43;. Come già ricordato sopra, fate molta attenzione ad inizializzare il generatore di numeri pseudo-casuali con lo stesso seme &#40;<code>1</code> in questo caso&#41;.</p>
<p>Eseguiamo ora il calcolo per 10.000 volte e facciamone l&#39;istogramma: osserviamo che la distribuzione è approssimativamente una Gaussiana, come previsto.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
mean_samples = [intmean(glc, sin, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>, <span class=hljs-number >100</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10_000</span>]
histogram(mean_samples, label=<span class=hljs-string >&quot;Media&quot;</span>)

glc = GLC(<span class=hljs-number >1</span>)  <span class=hljs-comment ># Reset the random generator</span>
mean_hm = [inthm(glc, sin, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>, <span class=hljs-number >1</span>, <span class=hljs-number >100</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10_000</span>]
histogram!(mean_hm, label=<span class=hljs-string >&quot;Hit-or-miss&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/mc_integrals.svg" alt="">
<p>Se l&#39;andamento dell&#39;errore è della forma <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo stretchy=false >(</mo><mi>N</mi><mo stretchy=false >)</mo><mo>=</mo><mi>k</mi><mi mathvariant=normal >/</mi><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">\epsilon(N) = k/\sqrt{N}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϵ</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.176665em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mord >/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9266650000000001em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span>, con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> numero di punti, allora nel nostro caso possiamo stimare <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> immediatamente dalla deviazione standard dei valori in <code>values</code> mediante la formula <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><msqrt><mi>N</mi></msqrt><mo>×</mo><mi>ϵ</mi><mo stretchy=false >(</mo><mi>N</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">k =
\sqrt{N} \times \epsilon(N)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9266650000000001em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.11333499999999996em;"><span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϵ</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mclose >)</span></span></span></span>:</p>
<pre><code class="julia hljs">k_mean = √<span class=hljs-number >100</span> * std(mean_samples)
k_hm = √<span class=hljs-number >100</span> * std(mean_hm)

println(<span class=hljs-string >&quot;K (media) = &quot;</span>, k_mean)
println(<span class=hljs-string >&quot;K (hit-or-miss) = &quot;</span>, k_hm)</code></pre><pre><code class="plaintext hljs">K (media) = 0.9574569402133133
K (hit-or-miss) = 1.4987026076211012
</code></pre>
<p>A questo punto, per rispondere alla domanda del problema, è sufficiente risolvere l&#39;equazione <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.001</mn><mo>=</mo><mi>k</mi><mi mathvariant=normal >/</mi><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">0.001 = k/\sqrt{N}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.001</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.176665em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mord >/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9266650000000001em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span> per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, ossia </p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>N</mi><mo>=</mo><msup><mrow><mo fence=true >(</mo><mfrac><mi>k</mi><mn>0.001</mn></mfrac><mo fence=true >)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N =
\left(\frac{k}{0.001}\right)^2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.604038em;vertical-align:-0.95003em;"></span><span class=minner ><span class=minner ><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.37144em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >0.001</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>
<p>.</p>
<pre><code class="julia hljs">noptim_mean = round(<span class=hljs-built_in >Int</span>, (k_mean/<span class=hljs-number >0.001</span>)^<span class=hljs-number >2</span>)
noptim_hm = round(<span class=hljs-built_in >Int</span>, (k_hm/<span class=hljs-number >0.001</span>)^<span class=hljs-number >2</span>)

println(<span class=hljs-string >&quot;N (media) = &quot;</span>, noptim_mean)
println(<span class=hljs-string >&quot;N (hit-or-miss) = &quot;</span>, noptim_hm)</code></pre><pre><code class="plaintext hljs">N (media) = 916724
N (hit-or-miss) = 2246110
</code></pre>
<p>Per verificare la correttezza del risultato, rifacciamo l&#39;istogramma. Siccome ci vuole molto tempo per ottenere il risultato, verifichiamo il risultato solo nel caso del metodo della media, e per un numero ridotto di realizzazioni &#40;1000 anziché 10.000&#41;:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
values = [intmean(glc, sin, <span class=hljs-number >0</span>, <span class=hljs-literal >π</span>, noptim_mean) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >1000</span>]
histogram(values, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/mc_intmean.svg" alt="">
<p>Il risultato è effettivamente corretto:</p>
<pre><code class="julia hljs">std(values)</code></pre><pre><code class="plaintext hljs">0.001000082648024251</code></pre>
<h2 id=lezione_11_metodi_monte_carlo ><a href="#lezione_11_metodi_monte_carlo" class=header-anchor >Lezione 11: Metodi Monte Carlo</a></h2>
<p>L&#39;esercizio di questa lezione è <strong>estremamente</strong> importante, perché le tecniche Monte Carlo sono molto diffuse in fisica. &#40;E inoltre questo è un tipo di tema d&#39;esame che ricorre spesso&#33;&#41;</p>
<p>Ne approfitto anche per mostrarvi un modo di scrivere codice che espliciti le unità di misura e faccia automaticamente un controllo dimensionale. In C&#43;&#43; questo sarebbe fattibile usando la programmazione template, che non è stata però quasi mai usata per lo svolgimento degli esercizi; tenete presente nei vostri futuri progetti che librerie come <a href="https://www.boost.org/doc/libs/1_65_0/doc/html/boost_units.html">Boost.units</a>, <a href="https://github.com/bernedom/SI">SI</a> o <a href="https://github.com/nholthaus/units">units</a> possono essere usate per specificare le unità di misura di variabili e costanti, e per verificarne la consistenza nel proprio codice.</p>
<p>Sfortunatamente, il modo in cui avete scritto programmi in questo semestre fa uso della programmazione <em>object-oriented</em>, che non è adatta per usare questo genere di librerie &#40;e più in generale per il calcolo numerico&#41;, perché avete dichiarato come <code>double</code> tutti i parametri di metodi come <code>Solutore::CercaZeri</code> o <code>Integral::integrate</code>, mentre per usare queste librerie C&#43;&#43; avreste dovuto definire sia <code>Solutore</code> che <code>integral</code> come classi template. Ad esempio:</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >template</span> &lt;<span class=hljs-keyword >typename</span> T, <span class=hljs-keyword >typename</span> Fn&gt;
<span class=hljs-keyword >class</span> <span class="hljs-title class_">Solutore</span> {
<span class=hljs-keyword >public</span>:
  <span class=hljs-built_in >Solutore</span>();

  <span class=hljs-function ><span class=hljs-keyword >virtual</span> T <span class=hljs-title >CercaZeri</span><span class=hljs-params >(T xmin, T xmax, Fn f,
                      T prec = <span class=hljs-number >1e-3</span>, <span class=hljs-type >int</span> nmax = <span class=hljs-number >100</span>)</span> </span>= <span class=hljs-number >0</span>;
};</code></pre>
<p>In questo modo, supponendo di usare la libreria <a href="https://github.com/nholthaus/units">units</a>, avreste potuto poi passare a <code>Solutore::CercaZeri</code> variabili dimensionali, perché il compilatore avrebbe selezionato il tipo <code>T</code> giusto &#40;lunghezza, tempo, etc.&#41;:</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> units::length;
<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> units::time;

Bisezione sol{};

<span class=hljs-comment >// We find the zero of a function f(x), where x is a length</span>
<span class=hljs-keyword >auto</span> result1 = sol.<span class=hljs-built_in >CercaZeri</span>(<span class=hljs-number >0.5</span>_m, <span class=hljs-number >1.5</span>_m, my_function, <span class=hljs-number >1e-4</span>_m);

<span class=hljs-comment >// We find the zero of a function g(t), where t is a time</span>
<span class=hljs-keyword >auto</span> result2 = sol.<span class=hljs-built_in >CercaZeri</span>(<span class=hljs-number >10.0</span>_s, <span class=hljs-number >15.0</span>_s, another_function, <span class=hljs-number >1e-2</span>_s);</code></pre>
<p>Ovviamente, né <code>my_function</code> né <code>another_function</code> sarebbero più state derivate da <code>FunzioneBase</code>, dovendo invece essere funzioni che accettano quantità delle dimensioni giuste. Ecco per quale motivo la programmazione <em>object-oriented</em> non è indicata per codici numerici: non permette la versatilità nei tipi dei dati garantita invece dalla programmazione con i template.</p>
<p>&#40;In un certo senso, Julia è invece un linguaggio dove <em>tutto</em> è un template, e ciò lo rende ideale per il calcolo scientifico&#41;.</p>
<h3 id=esercizio_110 ><a href="#esercizio_110" class=header-anchor >Esercizio 11.0</a></h3>
<p>Iniziamo con l&#39;importare la libreria <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a>, che implementa le unità di misura che ci servono. Importeremo esplicitamente quelle unità di misura che ci serviranno, perché la libreria di default non ne importa nessuno &#40;simboli come <code>m</code>, <code>s</code>, <code>mm</code>, etc., sono molto usati come nomi di variabili, e sarebbe un disastro se venissero tutti importati senza criterio&#33;&#41;.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Unitful
<span class=hljs-keyword >import</span> Unitful: m, cm, mm, nm, s, °, mrad, <span class=hljs-meta >@u_str</span></code></pre><pre><code class="plaintext hljs">ArgumentError: Package Unitful not found in current path.
- Run `import Pkg; Pkg.add(&quot;Unitful&quot;)` to install the Unitful package.
</code></pre>
<p>I simboli <code>nm</code>, <code>°</code> e <code>mrad</code> sono unità di misura che si possono usare direttamente nelle definizioni, come <code>x &#61; 10nm</code>. La macro <code>@u_str</code>, terminando con <code>_str</code>, indica che è una macro che può essere usata aggiungendo <code>u</code> dopo le stringhe per specificare le unità di misura. Questo è indispensabile per tipi più complessi dei semplici <code>m</code>, <code>cm</code>, <code>mm</code>, etc., che richiedano espressioni matematiche, come ad esempio <code>E &#61; 10u&quot;N/C&quot;</code> &#40;campo elettrico&#41;.</p>
<p>Definiamo una serie di variabili per le costanti fisiche del problema:</p>
<pre><code class="julia hljs">σ_θ = <span class=hljs-number >0.3</span>mrad;       <span class=hljs-comment ># I could have written σ_θ = 0.3u&quot;mrad&quot;</span>
θ<span class=hljs-number >0_</span>ref = <span class=hljs-number >90</span>°;        <span class=hljs-comment ># Similarly,           θ0_ref = 90u&quot;°&quot;</span>
Aref = <span class=hljs-number >2.7</span>;
Bref = <span class=hljs-number >6e4</span><span class=hljs-string >u&quot;nm^2&quot;</span>;
α = <span class=hljs-number >60.0</span>°;
λ<span class=hljs-number >1</span> = <span class=hljs-number >579.1</span>nm;
λ<span class=hljs-number >2</span> = <span class=hljs-number >404.7</span>nm;</code></pre><pre><code class="plaintext hljs">UndefVarError: mrad not defined
</code></pre>
<p>La funzione <code>n_cauchy</code> restituisce <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> supponendo vera la formula di Cauchy. La sintassi con un parametro usa i valori di riferimento di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> scritti sopra.</p>
<pre><code class="julia hljs">n_cauchy(λ, A, B) = sqrt(A + B / λ^<span class=hljs-number >2</span>)
n_cauchy(λ) = n_cauchy(λ, Aref, Bref)</code></pre><pre><code class="plaintext hljs">n_cauchy (generic function with 2 methods)</code></pre>
<p>La funzione <code>n</code> invece restituisce <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> in funzione della deviazione misurata <code>δ</code> dal prisma, dove <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> è il suo angolo di apertura &#40;definito sopra&#41;. Siccome la funzione <code>asin</code> &#40;arcoseno&#41; restituisce il valore in radianti, che è scomodo da leggere, definiamo <code>δ</code> in modo che esprima sempre il risultato in gradi.</p>
<pre><code class="julia hljs">n(δ) = sin((δ + α) / <span class=hljs-number >2</span>) / sin(α / <span class=hljs-number >2</span>)
δ(n) = uconvert(<span class=hljs-string >u&quot;°&quot;</span>, <span class=hljs-number >2</span>asin(n * sin(α / <span class=hljs-number >2</span>)) - α)</code></pre><pre><code class="plaintext hljs">LoadError: UndefVarError: @u_str not defined
in expression starting at none:1
</code></pre>
<p>Queste formule si ricavano banalmente dall&#39;inversione della formula di Cauchy; la funzione <code>A_and_B</code> calcola contemporaneamente <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, ed è stata definita per comodità:</p>
<pre><code class="julia hljs">A(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>) = (λ<span class=hljs-number >2</span>^<span class=hljs-number >2</span> * n(δ<span class=hljs-number >2</span>)^<span class=hljs-number >2</span> - λ<span class=hljs-number >1</span>^<span class=hljs-number >2</span> * n(δ<span class=hljs-number >1</span>)^<span class=hljs-number >2</span>) / (λ<span class=hljs-number >2</span>^<span class=hljs-number >2</span> - λ<span class=hljs-number >1</span>^<span class=hljs-number >2</span>)
B(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>) = (n(δ<span class=hljs-number >2</span>)^<span class=hljs-number >2</span> - n(δ<span class=hljs-number >1</span>)^<span class=hljs-number >2</span>) / (<span class=hljs-number >1</span>/λ<span class=hljs-number >2</span>^<span class=hljs-number >2</span> - <span class=hljs-number >1</span>/λ<span class=hljs-number >1</span>^<span class=hljs-number >2</span>)
A_and_B(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>) = (A(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>), B(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>))</code></pre><pre><code class="plaintext hljs">A_and_B (generic function with 1 method)</code></pre>
<p>Calcoliamo allora i valori di riferimento di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy=false >(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo stretchy=false >)</mo><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n(\lambda_1) = n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">λ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy=false >(</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy=false >)</mo><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n(\lambda_2) = n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">λ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, supponendo veri i valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> scritti sopra r&#40;<code>A_ref</code> e <code>B_ref</code>&#41;:</p>
<pre><code class="julia hljs">n1_ref, n2_ref = n_cauchy(λ<span class=hljs-number >1</span>), n_cauchy(λ<span class=hljs-number >2</span>)</code></pre><pre><code class="plaintext hljs">UndefVarError: λ1 not defined
</code></pre>
<p>Da <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> calcoliamo quanto aspettarci per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\delta_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\delta_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:</p>
<pre><code class="julia hljs">δ<span class=hljs-number >1_</span>ref, δ<span class=hljs-number >2_</span>ref = δ(n1_ref), δ(n2_ref)</code></pre><pre><code class="plaintext hljs">UndefVarError: δ not defined
</code></pre>
<p>Il vostro codice probabilmente stamperà angoli in radianti &#40;è la convenzione di <code>asin</code> in C&#43;&#43;&#41;, quindi convertiamo i valori sopra in modo che possiate confrontarli col risultato del vostro programma:</p>
<pre><code class="julia hljs">println(<span class=hljs-string >&quot;δ1_ref = &quot;</span>, uconvert(<span class=hljs-string >u&quot;rad&quot;</span>, δ<span class=hljs-number >1_</span>ref))
println(<span class=hljs-string >&quot;δ2_ref = &quot;</span>, uconvert(<span class=hljs-string >u&quot;rad&quot;</span>, δ<span class=hljs-number >2_</span>ref))</code></pre><pre><code class="plaintext hljs">LoadError: UndefVarError: @u_str not defined
in expression starting at none:1
</code></pre>
<p>A questo punto possiamo simulare l&#39;esperimento. La simulazione della misura di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\delta_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\delta_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> va fatta usando l&#39;approssimazione Gaussiana con i valori medi <code>δ1_ref</code> e <code>δ2_ref</code>, e la deviazione standard <code>σ_θ</code> data dal testo dell&#39;esercizio:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simulate_experiment(glc, nsim)
    n1_simul = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, nsim)
    n2_simul = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, nsim)

    A_simul = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, nsim)
    <span class=hljs-comment ># Here I create an array of values whose measurement unit</span>
    <span class=hljs-comment ># must be the same as `Bref`</span>
    B_simul = <span class=hljs-built_in >Array</span>{typeof(Bref)}(<span class=hljs-literal >undef</span>, nsim)

    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:nsim
        θ<span class=hljs-number >0</span> = randgauss(glc, θ<span class=hljs-number >0_</span>ref, σ_θ)
        θ<span class=hljs-number >1</span> = randgauss(glc, θ<span class=hljs-number >0_</span>ref + δ<span class=hljs-number >1_</span>ref, σ_θ)
        θ<span class=hljs-number >2</span> = randgauss(glc, θ<span class=hljs-number >0_</span>ref + δ<span class=hljs-number >2_</span>ref, σ_θ)
        δ<span class=hljs-number >1</span>, δ<span class=hljs-number >2</span> = θ<span class=hljs-number >1</span> - θ<span class=hljs-number >0</span>, θ<span class=hljs-number >2</span> - θ<span class=hljs-number >0</span>
        n1, n2 = n(δ<span class=hljs-number >1</span>), n(δ<span class=hljs-number >2</span>)
        a, b = A_and_B(λ<span class=hljs-number >1</span>, δ<span class=hljs-number >1</span>, λ<span class=hljs-number >2</span>, δ<span class=hljs-number >2</span>)

        n1_simul[i] = n1
        n2_simul[i] = n2

        A_simul[i] = a
        B_simul[i] = b
    <span class=hljs-keyword >end</span>

    (n1_simul, n2_simul, A_simul, B_simul)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">simulate_experiment (generic function with 1 method)</code></pre>
<p>Ecco i primi 5 valori della simulazione; controllate che siano gli stessi che ottenete voi, facendo attenzione di usare come seme <code>1</code> e che l&#39;ordine in cui chiamate la funzione per generare i numeri casuali sia la stessa del codice sopra:</p>
<ol>
<li><p><em>Prima</em> si genera <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>;</p>

<li><p><em>Poi</em> si generano <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\theta_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>

</ol>
<p>Nel fare i plot qui sotto mi limito a ripetere l&#39;esperimento 1000 volte &#40;il testo richiede 10.000 volte&#41;. I risultati non cambiano molto.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
n1_simul, n2_simul, A_simul, B_simul = simulate_experiment(glc, <span class=hljs-number >1000</span>)

<span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14s %14s %14s %14s\n&quot;</span>, <span class=hljs-string >&quot;n₁&quot;</span>, <span class=hljs-string >&quot;n₂&quot;</span>, <span class=hljs-string >&quot;A&quot;</span>, <span class=hljs-string >&quot;B [nm²]&quot;</span>)
println(repeat(<span class=hljs-string >&#x27;-&#x27;</span>, <span class=hljs-number >62</span>))
<span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    <span class=hljs-comment ># We use scientific notation for B, as it is ≪1. As we want to</span>
    <span class=hljs-comment ># avoid printing units for B (they are already in the table header),</span>
    <span class=hljs-comment ># we just «strip» nm² from it.</span>
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14.6f %14.6f %14.6f %14.6e\n&quot;</span>,
            n1_simul[i], n2_simul[i], A_simul[i], ustrip(<span class=hljs-string >u&quot;nm^2&quot;</span>, B_simul[i]))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">UndefVarError: Bref not defined
</code></pre>
<pre><code class="julia hljs">histogram([n1_simul, n2_simul],
          label = [<span class=hljs-string >&quot;n₁&quot;</span>, <span class=hljs-string >&quot;n₂&quot;</span>],
          layout = (<span class=hljs-number >2</span>, <span class=hljs-number >1</span>));</code></pre><pre><code class="plaintext hljs">UndefVarError: n1_simul not defined
</code></pre>
<p><span style="color:red;">// Image matching '/assets/lezione10/code/hist_n1_n2.svg' not found. //</span></p>
<pre><code class="julia hljs">scatter(n1_simul, n2_simul, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre><pre><code class="plaintext hljs">UndefVarError: n1_simul not defined
</code></pre>
<p><span style="color:red;">// Image matching '/assets/lezione10/code/scatter_n1_n2.svg' not found. //</span></p>
<p>Il package <code>Statistics</code> di Julia implementa il calcolo della covarianza tra due serie, che è uguale alla correlazione a meno di una normalizzazione. Definiamo quindi la funzione <code>corr</code>, che calcola il coefficiente di correlazione, analogamente a questa; nel vostro codice C&#43;&#43; dovrete invece implementarla usando la formula.</p>
<pre><code class="julia hljs">corr(x, y) = cov(x, y) / (std(x) * std(y))</code></pre><pre><code class="plaintext hljs">corr (generic function with 1 method)</code></pre>
<p>I valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ed <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> sono correlati, perché sono entrambi stati ricavati dalla medesima stima di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<pre><code class="julia hljs">corr(n1_simul, n2_simul)</code></pre><pre><code class="plaintext hljs">UndefVarError: n1_simul not defined
</code></pre>
<p>Nel fare l&#39;istogramma di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, rimuoviamo le unità di misura da quest&#39;ultimo, perché altrimenti Julia segnalerebbe che <code>A_simul</code> e <code>B_simul</code> sono incompatibili &#40;essendo combinati nella stessa chiamata ad <code>histogram</code>&#41;:</p>
<pre><code class="julia hljs">histogram([A_simul, ustrip.(<span class=hljs-string >u&quot;nm^2&quot;</span>, B_simul)],
          label = [<span class=hljs-string >&quot;A&quot;</span> <span class=hljs-string >&quot;B&quot;</span>],
          layout = (<span class=hljs-number >2</span>, <span class=hljs-number >1</span>))</code></pre><pre><code class="plaintext hljs">LoadError: UndefVarError: @u_str not defined
in expression starting at none:1
</code></pre>
<p><span style="color:red;">// Image matching '/assets/lezione10/code/hist_A_B.svg' not found. //</span></p>
<p>Facciamo anche un grafico X-Y</p>
<pre><code class="julia hljs">scatter(A_simul, B_simul, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre><pre><code class="plaintext hljs">UndefVarError: A_simul not defined
</code></pre>
<p><span style="color:red;">// Image matching '/assets/lezione10/code/scatter_A_B.svg' not found. //</span></p>
<p>Ricalcoliamo qui i coefficienti di correlazione nel caso in cui l&#39;esperimento sia rifatto 10.000 volte. Notate che creo di nuovo un generatore di numeri casuali.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
(n1_simul, n2_simul, A_simul, B_simul) = simulate_experiment(glc, <span class=hljs-number >10_000</span>)
println(<span class=hljs-string >&quot;Correlazione tra n1 e n2: &quot;</span>, corr(n1_simul, n2_simul))
println(<span class=hljs-string >&quot;Correlazione tra A e B: &quot;</span>, corr(A_simul, B_simul))</code></pre><pre><code class="plaintext hljs">UndefVarError: Bref not defined
</code></pre>
<h3 id=esercizio_111 ><a href="#esercizio_111" class=header-anchor >Esercizio 11.1</a></h3>
<p>L&#39;esercizio 11.1 è preso da un vecchio tema d&#39;esame, e va svolto in modo molto simile al precedente. Si tratta di misurare il coefficiente di viscosità <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> partendo dalla velocità di caduta di una sferetta di metallo all&#39;interno di un cilindro pieno di glicerina, tramite la formula </p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msub><mi>v</mi><mi>L</mi></msub><mo>=</mo><mfrac><mrow><mn>2</mn><msup><mi>R</mi><mn>2</mn></msup></mrow><mrow><mn>9</mn><mi>η</mi></mrow></mfrac><mo stretchy=false >(</mo><mi>ρ</mi><mo>−</mo><msub><mi>ρ</mi><mn>0</mn></msub><mo stretchy=false >)</mo><mi>g</mi><mo>=</mo><mfrac><mrow><mi mathvariant=normal >Δ</mi><mi>x</mi></mrow><mrow><mi mathvariant=normal >Δ</mi><mi>t</mi></mrow></mfrac><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex"> v_L =
\frac{2R^2}{9\eta}(\rho - \rho_0) g = \frac{\Delta x}{\Delta t}, </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.371548em;vertical-align:-0.8804400000000001em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.491108em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >9</span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >2</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mopen >(</span><span class="mord mathnormal">ρ</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">ρ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.04633em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.36033em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >Δ</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >Δ</span><span class="mord mathnormal">x</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mpunct >,</span></span></span></span></span>
<p>dove <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\Delta x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Δ</span><span class="mord mathnormal">x</span></span></span></span> è la lunghezza del tratto percorso in caduta dalla sferetta e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Δ</span><span class="mord mathnormal">t</span></span></span></span> il tempo impiegato. La relazione si inverte facilmente per dare </p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>η</mi><mo>=</mo><mfrac><mrow><mn>2</mn><msup><mi>R</mi><mn>2</mn></msup><mtext> </mtext><mi>g</mi><mtext> </mtext><mi mathvariant=normal >Δ</mi><mi>t</mi></mrow><mrow><mn>9</mn><mtext> </mtext><mi mathvariant=normal >Δ</mi><mi>x</mi></mrow></mfrac><mo stretchy=false >(</mo><mi>ρ</mi><mo>−</mo><msub><mi>ρ</mi><mn>0</mn></msub><mo stretchy=false >)</mo><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex">
\eta = \frac{2R^2\,g\,\Delta t}{9\,\Delta x}(\rho - \rho_0), </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.177108em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.491108em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >9</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >Δ</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >2</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >Δ</span><span class="mord mathnormal">t</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mopen >(</span><span class="mord mathnormal">ρ</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">ρ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mpunct >,</span></span></span></span></span>
<p>dove le quantità misurate in ognuno degli esperimenti Monte Carlo sono <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\Delta x
= x_1 - x_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Δ</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.73333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Δ</span><span class="mord mathnormal">t</span></span></span></span>.</p>
<p>Definiamo le costanti numeriche del problema, usando ancora Unitful.jl:</p>
<pre><code class="julia hljs">δt, δx, δR = <span class=hljs-number >0.01</span>s, <span class=hljs-number >0.001</span>m, <span class=hljs-number >0.0001</span>m;
ρ, ρ<span class=hljs-number >0</span> = <span class=hljs-number >2700.0</span><span class=hljs-string >u&quot;kg/m^3&quot;</span>, <span class=hljs-number >1250.0</span><span class=hljs-string >u&quot;kg/m^3&quot;</span>;
g = <span class=hljs-number >9.81</span><span class=hljs-string >u&quot;m/s^2&quot;</span>;
η_true = <span class=hljs-number >0.83</span><span class=hljs-string >u&quot;kg/m/s&quot;</span>;
R_true = [<span class=hljs-number >0.01</span>m, <span class=hljs-number >0.005</span>m];
x0 = <span class=hljs-number >20</span>cm;
x1 = <span class=hljs-number >60</span>cm;
Δx_true = x1 - x0;</code></pre><pre><code class="plaintext hljs">UndefVarError: s not defined
</code></pre>
<p>Definiamo anche alcune relazioni matematiche.</p>
<pre><code class="julia hljs">v_L(R, η) = <span class=hljs-number >2</span>R^<span class=hljs-number >2</span> / (<span class=hljs-number >9</span>η) * (ρ - ρ<span class=hljs-number >0</span>) * g;
Δt(R, Δx, η) = Δx / v_L(R, η);
Δt_true = [Δt(R, Δx_true, η_true) <span class=hljs-keyword >for</span> R <span class=hljs-keyword >in</span> R_true];
η(R, Δt, Δx) = <span class=hljs-number >2</span>R^<span class=hljs-number >2</span> * g * Δt / (<span class=hljs-number >9</span>Δx) * (ρ - ρ<span class=hljs-number >0</span>);</code></pre><pre><code class="plaintext hljs">UndefVarError: R_true not defined
</code></pre>
<p>Definiamo ora la funzione <code>simulate</code>, che effettua <em>due</em> esperimenti: uno con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0.01</mn><mtext> </mtext><mtext>m</mtext></mrow><annotation encoding="application/x-tex">R = 0.01\,\text{m}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.01</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >m</span></span></span></span></span> e l&#39;altro con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0.005</mn><mtext> </mtext><mtext>m</mtext></mrow><annotation encoding="application/x-tex">R = 0.005\,\text{m}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.005</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >m</span></span></span></span></span>.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simulate(glc::GLC, δx, δt, δR)
    <span class=hljs-comment ># Misura dell&#x27;altezza iniziale</span>
    cur_x0 = randgauss(glc, x0, δx)
    <span class=hljs-comment ># Misura dell&#x27;altezza finale</span>
    cur_x1 = randgauss(glc, x1, δx)

    <span class=hljs-comment ># Questo array di 2 elementi conterrà le due stime di η</span>
    <span class=hljs-comment ># (corrispondenti ai due possibili raggi della sferetta)</span>
    estimated_η = zeros(typeof(η_true), <span class=hljs-number >2</span>)
    <span class=hljs-keyword >for</span> case <span class=hljs-keyword >in</span> [<span class=hljs-number >1</span>, <span class=hljs-number >2</span>]
        <span class=hljs-comment ># Misura delle dimensioni della sferetta</span>
        cur_R = randgauss(glc, R_true[case], δR)
        cur_Δx = cur_x1 - cur_x0

        <span class=hljs-comment ># Misura del tempo necessario per cadere da cur_x0 a cur_x1</span>
        cur_Δt = randgauss(glc, Δt_true[case], δt)

        <span class=hljs-comment ># Stima di η</span>
        estimated_η[case] = η(cur_R, cur_Δt, cur_Δx)
    <span class=hljs-keyword >end</span>

    estimated_η
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">simulate (generic function with 1 method)</code></pre>
<p>Eseguiamo ora 1000 simulazioni e facciamo l&#39;istogramma della stima di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> per i due raggi della sferetta.</p>
<pre><code class="julia hljs">N = <span class=hljs-number >1_000</span>
glc = GLC(<span class=hljs-number >1</span>)

η<span class=hljs-number >1</span> = <span class=hljs-built_in >Array</span>{typeof(η_true)}(<span class=hljs-literal >undef</span>, N)
η<span class=hljs-number >2</span> = <span class=hljs-built_in >Array</span>{typeof(η_true)}(<span class=hljs-literal >undef</span>, N)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (η<span class=hljs-number >1</span>[i], η<span class=hljs-number >2</span>[i]) = simulate(glc, δx, δt, δR)
<span class=hljs-keyword >end</span>

histogram(η<span class=hljs-number >2</span>, label=<span class=hljs-string >&quot;R = <span class=hljs-subst >$(R_true[<span class=hljs-number >2</span>])</span>&quot;</span>)
histogram!(η<span class=hljs-number >1</span>, label=<span class=hljs-string >&quot;R = <span class=hljs-subst >$(R_true[<span class=hljs-number >1</span>])</span>&quot;</span>);</code></pre><pre><code class="plaintext hljs">UndefVarError: η_true not defined
</code></pre>
<p><span style="color:red;">// Image matching '/assets/lezione10/code/hist_eta1_eta2.svg' not found. //</span></p>
<p>Si tratta ora di stimare le incertezze di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span> al variare degli errori considerati. Notate che per usare <code>round</code> con quantità associate ad unità di misura è necessario specificare l&#39;unità di misura usata per arrotondare: con 4 cifre, il valore <code>1 m</code> potrebbe essere scritto come <code>1.0000 m</code> oppure <code>100.0000 cm</code>&#33;</p>
<pre><code class="julia hljs"><span class=hljs-comment ># In η1 ed η2 abbiamo già le stime di η considerando tutti</span>
<span class=hljs-comment ># e tre gli errori</span>
println(<span class=hljs-string >&quot;Tutti gli errori: δη(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))

<span class=hljs-comment ># Ora dobbiamo eseguire di nuovo N esperimenti, assumendo che</span>
<span class=hljs-comment ># l&#x27;errore sia presente in una sola delle tre quantità</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (η<span class=hljs-number >1</span>[i], η<span class=hljs-number >2</span>[i]) = simulate(glc, <span class=hljs-number >0.0</span>m, <span class=hljs-number >0.0</span>s, δR)
<span class=hljs-keyword >end</span>
println(<span class=hljs-string >&quot;Solo δR:          δη(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))

<span class=hljs-comment ># Idem</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (η<span class=hljs-number >1</span>[i], η<span class=hljs-number >2</span>[i]) = simulate(glc, <span class=hljs-number >0.0</span>m, δt, <span class=hljs-number >0.0</span>m)
<span class=hljs-keyword >end</span>
println(<span class=hljs-string >&quot;Solo δt:          δη(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))

<span class=hljs-comment ># Idem</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (η<span class=hljs-number >1</span>[i], η<span class=hljs-number >2</span>[i]) = simulate(glc, δx, <span class=hljs-number >0.0</span>s, <span class=hljs-number >0.0</span>m)
<span class=hljs-keyword >end</span>
println(<span class=hljs-string >&quot;Solo δx:          δη(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(η<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))</code></pre><pre><code class="plaintext hljs">LoadError: UndefVarError: @u_str not defined
in expression starting at none:3
</code></pre>

<div class=page-foot >
  <div class=copyright >
    &copy; Maurizio Tomasi. Last modified: January 02, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>