<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/tnds-notebooks/libs/katex/katex.min.css"> <link rel=stylesheet  href="/tnds-notebooks/libs/highlight/github.min.css"> <link rel=stylesheet  href="/tnds-notebooks/css/franklin.css"> <link rel=stylesheet  href="/tnds-notebooks/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/tnds-notebooks/assets/favicon.png"> <title>Lezioni 10 e 11</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <h1><a href="/tnds-notebooks/">TNDS</a></h1> <p class=lead >Prof. M.&nbsp;Tomasi</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/tnds-notebooks/">Home</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione07/">Lezione 07</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione08/">Lezione 08</a> <a class="sidebar-nav-item active" href="/tnds-notebooks/lezione10/">Lezioni 10 e 11</a> </nav> <p>&copy; Maurizio Tomasi.</p> </div> </div> <div class="content container"> <div class=franklin-content > <p><div class=franklin-toc ><ol><li><a href="#esercizio_100">Esercizio 10.0</a><ol><li><a href="#generatore_lineare_congruenziale">Generatore Lineare Congruenziale</a><li><a href="#distribuzione_esponenziale">Distribuzione esponenziale</a><li><a href="#distribuzione_gaussiana">Distribuzione Gaussiana</a><li><a href="#distribuzione_gaussiana_con_metodo_accept-reject">Distribuzione Gaussiana con metodo Accept-Reject</a></ol><li><a href="#esercizio_101">Esercizio 10.1</a><li><a href="#esercizio_102">Esercizio 10.2</a><li><a href="#esercizio_120">Esercizio 12.0</a><li><a href="#esercizio_121_attrito_viscoso_facoltativo">Esercizio 12.1 ‚Äî Attrito viscoso &#40;facoltativo&#41;</a></ol></div> </p> <p>Dal momento che la lezione 11 richiede di impiegare i codici sviluppati nella lezione 10, presento gli esercizi delle due lezioni in un&#39;unica pagina.</p> <h1 id=lezione_10 ><a href="#lezione_10" class=header-anchor >Lezione 10</a></h1> <p>Iniziamo importando i pacchetti che ci serviranno.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Printf
<span class=hljs-keyword >using</span> Plots
<span class=hljs-keyword >using</span> Statistics</code></pre> <h2 id=esercizio_100 ><a href="#esercizio_100" class=header-anchor >Esercizio 10.0</a></h2> <p>Definiamo una classe <code>GLC</code> che sia equivalente alla classe <code>Random</code> che vi viene richiesto di implementare in C&#43;&#43;.</p> <p>In Julia non esiste il concetto di ¬´classe¬ª, ma esistono le <code>struct</code> che funzionano in modo concettualmente simile. Non permettono di associare metodi, tranne eventualmente un semplice costruttore, e tutti i campi sono pubblici di default.</p> <h3 id=generatore_lineare_congruenziale ><a href="#generatore_lineare_congruenziale" class=header-anchor >Generatore Lineare Congruenziale</a></h3> <pre><code class="julia hljs"><span class=hljs-keyword >mutable struct</span> GLC
    a::<span class=hljs-built_in >UInt32</span>
    c::<span class=hljs-built_in >UInt32</span>
    seed::<span class=hljs-built_in >UInt32</span>

    GLC(myseed) = new(<span class=hljs-number >1664525</span>, <span class=hljs-number >1013904223</span>, myseed)
<span class=hljs-keyword >end</span></code></pre> <p>Il tipo <code>UInt32</code> corrisponde a <code>std::uint32_t</code> in C&#43;&#43;.</p> <p>Definiamo ora una funzione <code>rand</code> che restituisca un numero casuale floating-point compreso in un intervallo:</p> <pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >&quot;&quot;&quot;
    rand(glc::GLC, xmin, xmax)

Return a pseudo-random number uniformly distributed in the
interval [xmin, xmax).
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> rand(glc::GLC, xmin, xmax)
    glc.seed = <span class=hljs-built_in >UInt32</span>(glc.a * glc.seed + glc.c)
    xmin + (xmax - xmin) * glc.seed / (<span class=hljs-number >2.0</span>^<span class=hljs-number >32</span>)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">rand</code></pre>
<p>√à molto comodo avere anche una funzione <code>rand</code> che usi l&#39;intervallo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>.</p>
<pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >&quot;&quot;&quot;
    rand(glc::GLC)

Return a pseudo-random number uniformly distributed in the
interval [0, 1).
&quot;&quot;&quot;</span>
rand(glc::GLC) = rand(glc, <span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>)</code></pre><pre><code class="plaintext hljs">rand</code></pre>
<p>Questi sono i numeri che dovreste aspettarvi se avete implementato bene il vostro codice &#40;notate che i numeri cambiano se usate un seed diverso&#33;&#41;.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, rand(glc))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 0.23645552527159452
2: 0.3692706737201661
3: 0.5042420323006809
4: 0.7048832636792213
5: 0.05054362863302231
</code></pre>
<p>Preoccupatevi quindi di creare una serie di <code>assert</code> nel vostro codice C&#43;&#43; che verifichino che ottenete gli stessi valori se partite dallo stesso seme &#40;<code>1</code>&#41;, possibilmente in una funzione <code>test_random_numbers&#40;&#41;</code> invocata all&#39;inizio del vostro <code>main</code>.</p>
<p>Quando si implementano numeri pseudo-casuali, √® sempre bene farsi un&#39;idea della distribuzione dei valori. Disegnamo quindi l&#39;istogramma della distribuzione di un gran numero di campioni, e verifichiamo che siano uniformemente distribuiti nell&#39;intervallo &#91;0, 1&#41;.</p>
<pre><code class="julia hljs">histogram([rand(glc) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/rand_hist.svg" alt="">
<h3 id=distribuzione_esponenziale ><a href="#distribuzione_esponenziale" class=header-anchor >Distribuzione esponenziale</a></h3>
<p>Trattandosi di una formula semplice, in Julia si pu√≤ definire <code>randexp</code> con una sola riga di codice:</p>
<pre><code class="julia hljs"><span class=hljs-string >&quot;&quot;&quot;
    randexp(glc::GLC)

Return a positive pseudo-random number distributed with a
probability density ``p(x) = Œª e^{-Œª x}``.
&quot;&quot;&quot;</span>
randexp(glc::GLC, Œª) = -log(<span class=hljs-number >1</span> - rand(glc)) / Œª</code></pre><pre><code class="plaintext hljs">randexp</code></pre>
<p>Questi sono i numeri per i vostri <code>assert</code>:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, randexp(glc, <span class=hljs-number >1</span>))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 0.26978390490222603
2: 0.46087846840742835
3: 0.7016674397006556
4: 1.2203842845757569
5: 0.05186569884606859
</code></pre>
<p>Questo √® l&#39;istogramma</p>
<pre><code class="julia hljs">histogram([randexp(glc, <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/randexp_hist.svg" alt="">
<h3 id=distribuzione_gaussiana ><a href="#distribuzione_gaussiana" class=header-anchor >Distribuzione Gaussiana</a></h3>
<pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >raw&quot;&quot;&quot;
    randgauss(glc::GLC, Œº, œÉ)

Return a pseudo-random number distributed with a probability
density ``p(x) = \frac{1}{\sqrt{2œÄœÉ^2}}
\exp\left(-\frac{(x - Œº)^2}{2œÉ^2}\right)``, using the
Box-M√ºller algorithm.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> randgauss(glc::GLC, Œº, œÉ)
    s = rand(glc)
    t = rand(glc)
    x = sqrt(-<span class=hljs-number >2</span>log(s)) * cos(<span class=hljs-number >2</span><span class=hljs-literal >œÄ</span> * t)
    Œº + œÉ * x
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">randgauss</code></pre>
<p>All&#39;interno della funzione, nella riga in cui si assegna il valore a <code>x</code>, vi sareste potuti aspettare la riga</p>
<pre><code class="julia hljs">x = sqrt(-<span class=hljs-number >2</span>log(<span class=hljs-number >1</span> - s)) * cos(<span class=hljs-number >2</span><span class=hljs-literal >œÄ</span> * t)</code></pre>
<p>con il termine <code>2log&#40;1 - s&#41;</code> anzich√© <code>2log&#40;s&#41;</code>. I due termini <em>non</em> sono uguali, ovviamente, ma la loro distribuzione statistica invece s√¨: in entrambi i casi infatti l&#39;argomento del logaritmo √® distribuito uniformemente tra 0 ed 1. Per√≤ la scrittura <code>2log&#40;s&#41;</code> risparmia una sottrazione ed √® quindi lievemente pi√π veloce.</p>
<p>Questi sono i numeri per i vostri <code>assert</code>, assumendo ovviamente che anche voi usiate <code>log&#40;s&#41;</code> anzich√© <code>log&#40;1 - s&#41;</code>:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, randgauss(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 0.8431656465550212
2: 1.6726969052061536
3: 0.332826743781228
4: 1.3296417147047936
5: 0.16318824383921404
</code></pre>
<p>Questo √® l&#39;istogramma:</p>
<pre><code class="julia hljs">histogram([randgauss(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/randgauss_hist.svg" alt="">
<h3 id=distribuzione_gaussiana_con_metodo_accept-reject ><a href="#distribuzione_gaussiana_con_metodo_accept-reject" class=header-anchor >Distribuzione Gaussiana con metodo Accept-Reject</a></h3>
<pre><code class="julia hljs"><span class=hljs-meta >@doc</span> <span class=hljs-string >raw&quot;&quot;&quot;
    randgauss_ar(glc::GLC, Œº, œÉ)

Return a pseudo-random number distributed with a probability
density ``p(x) = \frac1{\sqrt{2œÄœÉ^2}}
\exp\left(-\frac{(x - Œº)^2}{2œÉ^2}\right)``, using the
accept-reject algorithm.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> randgauss_ar(glc::GLC, Œº, œÉ)
    <span class=hljs-keyword >while</span> <span class=hljs-literal >true</span>  <span class=hljs-comment ># Loop forever</span>
        x = rand(glc, -<span class=hljs-number >5.</span>, <span class=hljs-number >5.</span>)
        y = rand(glc)
        g = exp(-x^<span class=hljs-number >2</span> / <span class=hljs-number >2</span>)
        y ‚â§ g &amp;&amp; <span class=hljs-keyword >return</span> Œº + x * œÉ
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">randgauss_ar</code></pre>
<p>Questi sono i numeri per gli <code>assert</code>:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    println(i, <span class=hljs-string >&quot;: &quot;</span>, randgauss_ar(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">1: 2.0424203230068088
2: 2.828870958648622
3: 3.8616447784006596
4: 1.92200440261513
5: 0.30638940911740065
</code></pre>
<p>Questo √® l&#39;istogramma:</p>
<pre><code class="julia hljs">histogram([randgauss_ar(glc, <span class=hljs-number >2</span>, <span class=hljs-number >1</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10000</span>], label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/randgauss_ar_hist.svg" alt="">
<h2 id=esercizio_101 ><a href="#esercizio_101" class=header-anchor >Esercizio 10.1</a></h2>
<p>L&#39;esercizio √® molto semplice da implementare, ma richiede comunque una certa attenzione: bisogna studiare infatti molti casi &#40;ben 12 istogrammi&#41;, e questo richiede molto ordine e pulizia&#33; Imparare a scrivere codice ordinato √® importante soprattutto per il giorno dell&#39;esame: capita spesso che nei temi d&#39;esame si chieda di ripetere pi√π volte un calcolo o una simulazione, ed √® bene non usare copia-e-incolla ma strutturare il codice usando dei cicli <code>for</code> e implementando funzioni di supporto anzich√© rendere il <code>main</code> lungo centinaia di righe.</p>
<p>Iniziamo con l&#39;implementazione di un codice che riempia un vettore con i campioni casuali sommati <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> alla volta:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> computesums!(glc::GLC, n, vec)
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> eachindex(vec)
        accum = <span class=hljs-number >0.0</span>
        <span class=hljs-keyword >for</span> k <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:n
            accum += rand(glc)
        <span class=hljs-keyword >end</span>
        vec[i] = accum
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">computesums! (generic function with 1 method)</code></pre>
<p>&#40;in Julia c&#39;√® la convenzione di mettere il carattere <code>&#33;</code> alla fine delle funzioni che modificano uno dei loro argomenti: questo √® proprio il nostro caso, perch√© <code>vec</code> viene modificato da <code>computesums&#33;</code>&#41;</p>
<p>Facciamo una prova semplice:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
<span class=hljs-comment ># Array di *due* elementi</span>
vec = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, <span class=hljs-number >2</span>)
<span class=hljs-comment ># Chiediamo che in ogni elemento vengano sommati *cinque*</span>
<span class=hljs-comment ># numeri. Quindi ogni elemento di `vec` sar√† un numero</span>
<span class=hljs-comment ># casuale nell&#x27;intervallo 0‚Ä¶5.</span>
computesums!(glc, <span class=hljs-number >5</span>, vec)
println(<span class=hljs-string >&quot;vec[1] = &quot;</span>, vec[<span class=hljs-number >1</span>])
println(<span class=hljs-string >&quot;vec[2] = &quot;</span>, vec[<span class=hljs-number >2</span>])</code></pre><pre><code class="plaintext hljs">vec[1] = 1.865395123604685
vec[2] = 2.356209162855521
</code></pre>
<p>Potete usare questi numeri in un <code>assert</code> per verificare la vostra implementazione di <code>compute_sums</code> &#40;mettete pure tutto nello stesso file del <code>main</code>&#41;:</p>
<pre><code class="cpp hljs"><span class=hljs-function ><span class=hljs-type >void</span> <span class=hljs-title >test_compute_sums</span><span class=hljs-params >()</span> </span>{
  <span class=hljs-function >std::vector&lt;<span class=hljs-type >double</span>&gt; <span class=hljs-title >vec</span><span class=hljs-params >(<span class=hljs-number >2</span>)</span></span>;  <span class=hljs-comment >// Attenzione, parentesi *tonde* qui!</span>

  RandomGen rng{<span class=hljs-number >1</span>};
  <span class=hljs-built_in >compute_sums</span>(rng, <span class=hljs-number >5</span>, vec);
  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(vec[<span class=hljs-number >0</span>], <span class=hljs-number >1.7307902472093701</span>));
  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(vec[<span class=hljs-number >1</span>], <span class=hljs-number >1.7124183257110417</span>));
  <span class=hljs-built_in >println</span>(cerr, <span class=hljs-string >&quot;compute_sums() is correct, hurrah! ü•≥&quot;</span>);
}</code></pre>
<p>Ora ci occorre invocare questa funzione pi√π volte facendo variare <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> da 1 a 12, e producendo un istogramma ogni volta.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
vec = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, <span class=hljs-number >100_000</span>)

list_of_N = <span class=hljs-number >1</span>:<span class=hljs-number >12</span>
list_of_histograms = []
list_of_sigmas = <span class=hljs-built_in >Float64</span>[]
<span class=hljs-keyword >for</span> n <span class=hljs-keyword >in</span> list_of_N
    computesums!(glc, n, vec)
    push!(list_of_histograms, histogram(vec, bins = <span class=hljs-number >20</span>, title = <span class=hljs-string >&quot;N = <span class=hljs-variable >$n</span>&quot;</span>))
    push!(list_of_sigmas, std(vec))
<span class=hljs-keyword >end</span>
plot(
    list_of_histograms...,
    layout = (<span class=hljs-number >3</span>, <span class=hljs-number >4</span>),
    size = (<span class=hljs-number >900</span>, <span class=hljs-number >600</span>),
    legend = <span class=hljs-literal >false</span>,
)</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/es10_1_histogram.svg" alt="">
<p>Notate che, grazie alla definizione della funzione <code>computesums&#33;</code>, il ciclo <code>for</code> √® stato ridotto ad appena tre righe. Inoltre proprio l&#39;uso del <code>for</code> ha evitato quegli orribili copia-e-incolla che spesso i docenti trovano nelle correzioni degli esami scritti.</p>
<p>Il seguente √® un esempio di come <strong>non</strong> implementare questo esercizio; √® un vero esercizio, consegnato da uno studente pochi anni fa. √à una vera e propria ‚Äúgalleria degli orrori‚Äù&#33;</p>
<pre><code class="cpp hljs"><span class=hljs-comment >// üëø NON BASATEVI SU QUESTO CODICE! üëø</span>

<span class=hljs-function >std::vector&lt;<span class=hljs-type >double</span>&gt; <span class=hljs-title >vec</span><span class=hljs-params >(<span class=hljs-number >100&#x27;000</span>)</span></span>;

<span class=hljs-comment >// Aargh! Qui scrive di nuovo il numero 100&#x27;000 anzich√© usare `ssize(vec)`:</span>
<span class=hljs-comment >// cosa succede se poi durante l&#x27;esame voleva usare un numero minore</span>
<span class=hljs-comment >// per risparmiare tempo? Deve cambiare tutte le occorrenze!</span>
<span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> k{}; k &lt; <span class=hljs-number >100&#x27;000</span>; ++k) {
  vec[k] = <span class=hljs-number >0.0</span>;   <span class=hljs-comment >// Per giunta qui non usa neppure vec.at(k),</span>
                  <span class=hljs-comment >// quindi se riduce il numero 100&#x27;000 nella</span>
                  <span class=hljs-comment >// definizione di `vec` ma non nel ciclo `for`,</span>
                  <span class=hljs-comment >// qui poteva avere un ‚Äúsegmentation fault‚Äù!</span>
  <span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> i{}; i &lt; <span class=hljs-number >1</span>; ++i)
    vec[k] += rand.<span class=hljs-built_in >Unif</span>(<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>);
}

<span class=hljs-comment >// Ok, invece che fare una sola figura con 12 grafici sceglie di</span>
<span class=hljs-comment >// creare 12 file PNG distinti‚Ä¶ √® pi√π faticoso per√≤ poi</span>
<span class=hljs-comment >// controllare i risultati e confrontare gli istogrammi!</span>
Gnuplot plt1{};
plt<span class=hljs-number >1.</span><span class=hljs-built_in >redirect_to_svg</span>(<span class=hljs-string >&quot;n1.png&quot;</span>);
plt<span class=hljs-number >1.</span><span class=hljs-built_in >histogram</span>(vec, <span class=hljs-number >20</span>, <span class=hljs-string >&quot;N = 1&quot;</span>);
plt<span class=hljs-number >1.</span><span class=hljs-built_in >show</span>();

<span class=hljs-comment >// Caso con n = 2</span>

<span class=hljs-comment >// NOOOO! Tutto quanto segue √® un copia-e-incolla del codice sopra!</span>
<span class=hljs-comment >// Terribile!</span>
<span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> k{}; k &lt; <span class=hljs-number >100&#x27;000</span>; ++k) {
  vec[k] = <span class=hljs-number >0.0</span>;
  <span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> i{}; i &lt; <span class=hljs-number >2</span>; ++i)
    vec[k] += rand.<span class=hljs-built_in >Unif</span>(<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>);
}

Gnuplot plt2{};
plt<span class=hljs-number >3.</span><span class=hljs-built_in >redirect_to_svg</span>(<span class=hljs-string >&quot;n3.png&quot;</span>);
plt<span class=hljs-number >3.</span><span class=hljs-built_in >histogram</span>(vec, <span class=hljs-number >20</span>, <span class=hljs-string >&quot;N = 3&quot;</span>);
plt<span class=hljs-number >3.</span><span class=hljs-built_in >show</span>();

<span class=hljs-comment >// Caso con n = 3</span>
<span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> k{}; k &lt; <span class=hljs-number >100&#x27;000</span>; ++k) {
  vec[k] = <span class=hljs-number >0.0</span>;
  <span class=hljs-keyword >for</span>(<span class=hljs-type >int</span> i{}; i &lt; <span class=hljs-number >3</span>; ++i)
    vec[k] += rand.<span class=hljs-built_in >Unif</span>(<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>);
}

Gnuplot plt3{};
plt<span class=hljs-number >3.</span><span class=hljs-built_in >redirect_to_svg</span>(<span class=hljs-string >&quot;n3.png&quot;</span>);
plt<span class=hljs-number >3.</span><span class=hljs-built_in >histogram</span>(vec, <span class=hljs-number >20</span>, <span class=hljs-string >&quot;N = 3&quot;</span>);
plt<span class=hljs-number >3.</span><span class=hljs-built_in >show</span>();

<span class=hljs-comment >// Il codice continua tutto cos√¨‚Ä¶ ci siamo capiti!</span>
<span class=hljs-comment >// ‚Ä¶</span></code></pre>
<p>Il codice Julia evita di ricorrere ai copia-e-incolla implementando una funzione <code>computesums&#33;</code> e chiamandola pi√π volte all&#39;interno di un ciclo <code>for</code>. Questo approccio √® estremamente elegante üòá e ha molti vantaggi rispetto al disperato copia-e-incolla del malefico esempio üëø:</p>
<ul>
<li><p>Ci mettete meno tempo a scriverlo, e in un esame il tempo √® sempre prezioso;</p>

<li><p>Se scegliete l&#39;approccio ‚Äúcopia-e-incolla‚Äù üëø e vi rendete conto di un   errore nel codice che avete appena copiato &#40;ad esempio, una parentesi non chiusa&#41;,   dovete correggerlo dodici volte‚Ä¶ ma nel caso üòá l&#39;errore va corretto una   volta sola&#33; E anche questo √® un bel risparmio di tempo.</p>

<li><p>Il codice üòá √® pi√π semplice da leggere, e quindi √® pi√π facile individuare   errori &#40;ci sono meno posti in cui il problema potrebbe nascondersi&#41;</p>

<li><p>Se vi rendete conto che il programma ci mette troppo per essere   eseguito, e questo vi √® di impiccio perch√© i risultati non vi   convincono e prevedete di doverlo eseguire molte volte, √®   semplice limitare ad esempio i valori di <code>N</code> da esplorare nel   codice üòá, limitandovi ad esempio ai primi 5 casi anzich√© a   tutti e 12. Nel codice üëø invece, dovete commentare decine di   righe di codice, col rischio di commentare qualche variabile   importante che vi serve alla fine del programma e che quindi   causa errori di compilazione‚Ä¶</p>

</ul>
<p>Ora creiamo il grafico con l&#39;andamento della deviazione standard &#40;calcolata nell&#39;esempio sopra con la funzione <code>Statistics.std</code>&#41;, memorizzata in <code>list_of_sigmas</code>:</p>
<pre><code class="julia hljs">plot(list_of_N, list_of_sigmas,
     xaxis = :log10, yaxis = :log10, label = <span class=hljs-string >&quot;&quot;</span>,
     xlabel = <span class=hljs-string >&quot;N&quot;</span>, ylabel = <span class=hljs-string >&quot;Standard deviation œÉ&quot;</span>)</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/es10_1_std.svg" alt="">
<h2 id=esercizio_102 ><a href="#esercizio_102" class=header-anchor >Esercizio 10.2</a></h2>
<p>Questa √® una semplice implementazione dell&#39;integrale della media:</p>
<pre><code class="julia hljs"><span class=hljs-string >&quot;&quot;&quot;
    intmean(glc::GLC, fn, a, b, N)

Evaluate the integral of `fn(x)` in the interval ``[a, b]``
using the mean method with ``N`` points.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> intmean(glc::GLC, fn, a, b, N)
    (b - a) * sum([fn(rand(glc, a, b)) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N]) / N
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">intmean</code></pre>
<p>L&#39;integrale <em>hit-or-miss</em> √® solo lievemente pi√π complicato:</p>
<pre><code class="julia hljs"><span class=hljs-string >&quot;&quot;&quot;
    inthm(glc::GLC, fn, a, b, fmax, N)

Evaluate the integral of `fn(x)` in the interval ``[a, b]``
using the hit-or-miss method with ``N`` points, assuming that
`fn(x)` assumes values in the range `[0, fmax]`.
&quot;&quot;&quot;</span>
<span class=hljs-keyword >function</span> inthm(glc::GLC, fn, a, b, fmax, N)
    hits = <span class=hljs-number >0</span>
    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
        x = rand(glc, a, b)
        y = rand(glc, <span class=hljs-number >0</span>, fmax)
        y ‚â§ fn(x) &amp;&amp; (hits += <span class=hljs-number >1</span>)
    <span class=hljs-keyword >end</span>

    hits / N * (b - a) * fmax
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">inthm</code></pre>
<p>Verifichiamo che il codice compili, e che produca un risultato sensato. Teniamo presente che <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>‚à´</mo><mn>0</mn><mrow><mi>œÄ</mi><mi mathvariant=normal >/</mi><mn>2</mn></mrow></msubsup><mi>x</mi><mi>sin</mi><mo>‚Å°</mo><mi>x</mi><mtext>‚Äâ</mtext><mi mathvariant=normal >d</mi><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\int_0^{\pi/2} x \sin x\,\mathrm{d}x = 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.43872em;vertical-align:-0.35582em;"></span><span class=mop ><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">‚à´</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.0829em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.2579000000000002em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">œÄ</span><span class="mord mtight">/2</span></span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.35582em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathrm">d</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span>; inoltre, siccome <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>sin</mi><mo>‚Å°</mo><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">x \sin(x)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span> √® una funzione limitata in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span>, possiamo porre <code>fmax &#61; œÄ/2</code> nella chiamata a <code>inthm</code>:</p>
<pre><code class="julia hljs">xsinx(x) = x * sin(x)
println(<span class=hljs-string >&quot;Integrale (metodo media):&quot;</span>, intmean(GLC(<span class=hljs-number >1</span>), xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >œÄ</span>/<span class=hljs-number >2</span>, <span class=hljs-number >100</span>))
println(<span class=hljs-string >&quot;Integrale (metodo hit-or-miss):&quot;</span>, inthm(GLC(<span class=hljs-number >1</span>), xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >œÄ</span>/<span class=hljs-number >2</span>, <span class=hljs-literal >œÄ</span>/<span class=hljs-number >2</span>, <span class=hljs-number >100</span>))</code></pre><pre><code class="plaintext hljs">Integrale (metodo media):1.0178979999547204
Integrale (metodo hit-or-miss):1.1596785171279995
</code></pre>
<p>Implementate degli <code>assert</code> che verifichino che ottenete gli stessi risultati nella vostra implementazione C&#43;&#43;. Come gi√† ricordato sopra, fate molta attenzione ad inizializzare il generatore di numeri pseudo-casuali con lo stesso seme &#40;<code>1</code> in questo caso&#41;. Notate anche che il codice sopra usa <strong>due</strong> generatori di numeri casuali: uno per <code>intmean</code> e l&#39;altro per <code>inthm</code>. Se voi invece ne usate uno solo e chiamate <code>intmean</code> e poi <code>inthm</code> passando sempre quello, anche se avete implementato correttamente entrambi i metodi, per <code>intmean</code> lo stesso numero ma per <code>inthm</code> un numero diverso&#33;</p>
<p>Eseguiamo ora il calcolo per 10.000 volte e facciamone l&#39;istogramma: osserviamo che la distribuzione √® approssimativamente una Gaussiana, come previsto.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)  <span class=hljs-comment ># Reset the random generator</span>
mean_hm = [inthm(glc, xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >œÄ</span> / <span class=hljs-number >2</span>, <span class=hljs-literal >œÄ</span> / <span class=hljs-number >2</span>, <span class=hljs-number >100</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10_000</span>]
histogram(mean_hm, label=<span class=hljs-string >&quot;Hit-or-miss&quot;</span>);

glc = GLC(<span class=hljs-number >1</span>)
mean_samples = [intmean(glc, xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >œÄ</span> / <span class=hljs-number >2</span>, <span class=hljs-number >100</span>) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10_000</span>]
histogram!(mean_samples, label=<span class=hljs-string >&quot;Media&quot;</span>)</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/mc_integrals.svg" alt="">
<p>Passiamo ora al punto 2: calcoliamo 10.000 volte il valore dell‚Äôintegrale variando il valore di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> e disegnamo gli istogrammi:</p>
<pre><code class="julia hljs">list_of_N = [<span class=hljs-number >500</span>, <span class=hljs-number >1_000</span>, <span class=hljs-number >5_000</span>, <span class=hljs-number >10_000</span>, <span class=hljs-number >50_000</span>, <span class=hljs-number >100_000</span>]
list_of_plots = []
list_of_errors = []
<span class=hljs-keyword >for</span> N <span class=hljs-keyword >in</span> list_of_N
    <span class=hljs-keyword >let</span> samples = [intmean(glc, xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >œÄ</span> / <span class=hljs-number >2</span>, N) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >10_000</span>]
        push!(list_of_plots, histogram(samples, label=<span class=hljs-string >&quot;N = <span class=hljs-variable >$N</span>&quot;</span>))
        push!(list_of_errors, std(samples))
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
plot(list_of_plots..., layout=(<span class=hljs-number >3</span>, <span class=hljs-number >2</span>), legend=<span class=hljs-literal >false</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/mc_integrals_varying_N.svg" alt="">
<p>Questo √® il grafico con l‚Äôandamento dell‚Äôerrore:</p>
<pre><code class="julia hljs">scatter(
    list_of_N,
    list_of_errors,
    xlabel = <span class=hljs-string >&quot;N&quot;</span>,
    ylabel = <span class=hljs-string >&quot;Errore&quot;</span>,
    xaxis = :log10,
    yaxis = :log10,
)</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/mc_integrals_err_plot.svg" alt="">
<p>E questi sono i punti calcolati:</p>
<pre><code class="julia hljs">println(<span class=hljs-string >&quot;N       Errore&quot;</span>)
<span class=hljs-keyword >for</span> (cur_n, cur_err) <span class=hljs-keyword >in</span> zip(list_of_N, list_of_errors)
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%d\t%.5f\n&quot;</span>, cur_n, cur_err)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">N       Errore
500	0.03541
1000	0.02521
5000	0.01128
10000	0.00797
50000	0.00352
100000	0.00253
</code></pre>
<p>Se l&#39;andamento dell&#39;errore √® della forma <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>œµ</mi><mo stretchy=false >(</mo><mi>N</mi><mo stretchy=false >)</mo><mo>=</mo><mi>k</mi><mi mathvariant=normal >/</mi><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">\epsilon(N) = k/\sqrt{N}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">œµ</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.176665em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mord >/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9266650000000001em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span>, con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> numero di punti, allora nel nostro caso possiamo stimare <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> immediatamente dalla deviazione standard dei valori in <code>values</code> mediante la formula <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><msqrt><mi>N</mi></msqrt><mo>√ó</mo><mi>œµ</mi><mo stretchy=false >(</mo><mi>N</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">k =
\sqrt{N} \times \epsilon(N)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9266650000000001em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.11333499999999996em;"><span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >√ó</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">œµ</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mclose >)</span></span></span></span>:</p>
<pre><code class="julia hljs">k_mean = ‚àö<span class=hljs-number >100</span> * std(mean_samples)
k_hm = ‚àö<span class=hljs-number >100</span> * std(mean_hm)

println(<span class=hljs-string >&quot;K (media) = &quot;</span>, k_mean)
println(<span class=hljs-string >&quot;K (hit-or-miss) = &quot;</span>, k_hm)</code></pre><pre><code class="plaintext hljs">K (media) = 0.8028925606426461
K (hit-or-miss) = 1.2294702831455502
</code></pre>
<p>A questo punto, per rispondere alla domanda del problema, √® sufficiente risolvere l&#39;equazione <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.001</mn><mo>=</mo><mi>k</mi><mi mathvariant=normal >/</mi><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">0.001 = k/\sqrt{N}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.001</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.176665em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mord >/</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.9266650000000001em;"><span class=svg-align  style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord  style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class=pstrut  style="height:3em;"></span><span class=hide-tail  style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span> per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, ossia </p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>N</mi><mo>=</mo><msup><mrow><mo fence=true >(</mo><mfrac><mi>k</mi><mn>0.001</mn></mfrac><mo fence=true >)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N =
\left(\frac{k}{0.001}\right)^2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.604038em;vertical-align:-0.95003em;"></span><span class=minner ><span class=minner ><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.37144em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >0.001</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>
<p>.</p>
<pre><code class="julia hljs">target_Œµ = <span class=hljs-number >0.001</span>
noptim_mean = round(<span class=hljs-built_in >Int</span>, (k_mean / target_Œµ)^<span class=hljs-number >2</span>)
noptim_hm = round(<span class=hljs-built_in >Int</span>, (k_hm / target_Œµ)^<span class=hljs-number >2</span>)

println(<span class=hljs-string >&quot;N (media) = &quot;</span>, noptim_mean)
println(<span class=hljs-string >&quot;N (hit-or-miss) = &quot;</span>, noptim_hm)</code></pre><pre><code class="plaintext hljs">N (media) = 644636
N (hit-or-miss) = 1511597
</code></pre>
<p>Per verificare la correttezza del risultato, rifacciamo l&#39;istogramma. Siccome ci vuole molto tempo per ottenere il risultato, verifichiamo il risultato solo nel caso del metodo della media, e per un numero ridotto di realizzazioni &#40;1000 anzich√© 10.000&#41;:</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
values = [intmean(glc, xsinx, <span class=hljs-number >0</span>, <span class=hljs-literal >œÄ</span> / <span class=hljs-number >2</span>, noptim_mean) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >1000</span>]
histogram(values, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/mc_intmean.svg" alt="">
<p>Il risultato √® effettivamente corretto:</p>
<pre><code class="julia hljs">std(values)</code></pre><pre><code class="plaintext hljs">0.0009905890238285527</code></pre>
<h1 id=lezione_12_simulazione_di_un_esperimento ><a href="#lezione_12_simulazione_di_un_esperimento" class=header-anchor >Lezione 12: Simulazione di un esperimento</a></h1>
<p>L&#39;esercizio di questa lezione √® <strong>estremamente</strong> importante, perch√© le tecniche Monte Carlo sono molto diffuse in fisica. &#40;E inoltre questo √® un tipo di tema d&#39;esame che ricorre spesso&#33;&#41;</p>
<p>Ne approfitto anche per mostrarvi un modo di scrivere codice che espliciti le unit√† di misura e faccia automaticamente un controllo dimensionale. In C&#43;&#43; questo sarebbe fattibile usando la programmazione template, che non √® stata per√≤ quasi mai usata per lo svolgimento degli esercizi; tenete presente nei vostri futuri progetti che librerie come <a href="https://mpusz.github.io/mp-units/latest/">mp-units</a>, <a href="https://www.boost.org/doc/libs/1_65_0/doc/html/boost_units.html">Boost.units</a>, <a href="https://github.com/bernedom/SI">SI</a>, <a href="https://github.com/nholthaus/units">units</a>, etc. possono essere usate per specificare le unit√† di misura di variabili e costanti, e per verificarne la consistenza nel proprio codice.</p>
<p>Sfortunatamente, il modo in cui avete scritto programmi in questo semestre fa uso della programmazione <em>object-oriented</em>, che non √® adatta per usare questo genere di librerie &#40;e pi√π in generale per il calcolo numerico&#41;, perch√© avete dichiarato come <code>double</code> tutti i parametri di metodi come <code>Solutore::CercaZeri</code> o <code>Integral::integrate</code>, mentre per usare queste librerie C&#43;&#43; avreste dovuto definire sia <code>Solutore</code> che <code>integral</code> come classi template. Ad esempio:</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >template</span> &lt;<span class=hljs-keyword >typename</span> T, <span class=hljs-keyword >typename</span> Fn&gt;
<span class=hljs-keyword >class</span> <span class="hljs-title class_">Solutore</span> {
<span class=hljs-keyword >public</span>:
  <span class=hljs-built_in >Solutore</span>();

  <span class=hljs-function ><span class=hljs-keyword >virtual</span> T <span class=hljs-title >CercaZeri</span><span class=hljs-params >(T xmin, T xmax, Fn f,
                      T prec = <span class=hljs-number >1e-3</span>, <span class=hljs-type >int</span> nmax = <span class=hljs-number >100</span>)</span> </span>= <span class=hljs-number >0</span>;
};</code></pre>
<p>In questo modo, supponendo di usare la libreria <a href="https://github.com/nholthaus/units">units</a>, avreste potuto poi passare a <code>Solutore::CercaZeri</code> variabili dimensionali, perch√© il compilatore avrebbe selezionato il tipo <code>T</code> giusto &#40;lunghezza, tempo, etc.&#41;:</p>
<pre><code class="cpp hljs"><span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> units::length;
<span class=hljs-keyword >using</span> <span class=hljs-keyword >namespace</span> units::time;

Bisezione sol{};

<span class=hljs-comment >// We find the zero of a function f(x), where x is a length</span>
<span class=hljs-keyword >auto</span> result1 = sol.<span class=hljs-built_in >CercaZeri</span>(<span class=hljs-number >0.5</span>_m, <span class=hljs-number >1.5</span>_m, my_function, <span class=hljs-number >1e-4</span>_m);

<span class=hljs-comment >// We find the zero of a function g(t), where t is a time</span>
<span class=hljs-keyword >auto</span> result2 = sol.<span class=hljs-built_in >CercaZeri</span>(<span class=hljs-number >10.0</span>_s, <span class=hljs-number >15.0</span>_s, another_function, <span class=hljs-number >1e-2</span>_s);</code></pre>
<p>Ovviamente, n√© <code>my_function</code> n√© <code>another_function</code> sarebbero pi√π state derivate da <code>FunzioneBase</code>, dovendo invece essere funzioni che accettano quantit√† delle dimensioni giuste.</p>
<p>&#40;In Julia questo tipo di programmazione √® naturale perch√© in un certo senso <em>tutto</em> √® un template, e ci√≤ lo rende ideale per il calcolo scientifico. Vedremo meglio questo aspetto nel seminario ‚Äújolly‚Äù che terr√≤ dopo la sessione di esami per chi √® interessato&#41;.</p>
<h2 id=esercizio_120 ><a href="#esercizio_120" class=header-anchor >Esercizio 12.0</a></h2>
<p>Iniziamo con l&#39;importare la libreria <a href="https://github.com/PainterQubits/Unitful.jl">Unitful.jl</a>, che implementa le unit√† di misura che ci servono. Importeremo esplicitamente quelle unit√† di misura che ci serviranno, perch√© la libreria di default non ne importa nessuno &#40;simboli come <code>m</code>, <code>s</code>, <code>mm</code>, etc., sono molto usati come nomi di variabili, e sarebbe un disastro se venissero tutti importati senza criterio&#33;&#41;.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Unitful
<span class=hljs-keyword >import</span> Unitful: m, cm, mm, nm, s, ¬∞, mrad, <span class=hljs-meta >@u_str</span></code></pre>
<p>I simboli <code>nm</code>, <code>¬∞</code> e <code>mrad</code> sono unit√† di misura che si possono usare direttamente nelle definizioni, come <code>x &#61; 10nm</code>. La macro <code>@u_str</code>, terminando con <code>_str</code>, indica che pu√≤ essere usata aggiungendo <code>u</code> dopo le stringhe per specificare le unit√† di misura. Questo √® indispensabile per tipi pi√π complessi dei semplici <code>m</code>, <code>cm</code>, <code>mm</code>, etc., che richiedano espressioni matematiche, come ad esempio i campi elettrici: <code>E &#61; 10u&quot;N/C&quot;</code>.</p>
<p>Definiamo una serie di variabili per le costanti fisiche del problema:</p>
<pre><code class="julia hljs">œÉ_Œ∏ = <span class=hljs-number >0.3</span>mrad;       <span class=hljs-comment ># Avrei potuto scrivere œÉ_Œ∏ = 0.3u&quot;mrad&quot;</span>
Œ∏<span class=hljs-number >0_</span>ref = <span class=hljs-number >90</span>¬∞;        <span class=hljs-comment ># Ugualmente,           Œ∏0_ref = 90u&quot;¬∞&quot;</span>
Aref = <span class=hljs-number >2.7</span>;
Bref = <span class=hljs-number >6e4</span><span class=hljs-string >u&quot;nm^2&quot;</span>;   <span class=hljs-comment ># Qui devo usare `u` perch√© nm¬≤ √® troppo complicato</span>
Œ± = <span class=hljs-number >60.0</span>¬∞;
Œª<span class=hljs-number >1</span> = <span class=hljs-number >579.1</span>nm;
Œª<span class=hljs-number >2</span> = <span class=hljs-number >404.7</span>nm;</code></pre>
<p>La funzione <code>n_cauchy</code> restituisce <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> supponendo vera la formula di Cauchy. La sintassi con un parametro usa i valori di riferimento di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> scritti sopra.</p>
<pre><code class="julia hljs">n_cauchy(Œª, A, B) = sqrt(A + B / Œª^<span class=hljs-number >2</span>)
n_cauchy(Œª) = n_cauchy(Œª, Aref, Bref)</code></pre><pre><code class="plaintext hljs">n_cauchy (generic function with 2 methods)</code></pre>
<p>La funzione <code>n</code> invece restituisce <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> in funzione della deviazione misurata <code>Œ¥</code> dal prisma, dove <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ±</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">Œ±</span></span></span></span> √® il suo angolo di apertura &#40;definito sopra&#41;. Siccome la funzione <code>asin</code> &#40;arcoseno&#41; restituisce il valore in radianti, che √® scomodo da leggere, definiamo <code>Œ¥</code> in modo che esprima sempre il risultato in gradi: per questo scopo c&#39;√® la funzione <code>uconvert</code>, che richiede come primo parametro l&#39;unit√† di misura di <em>destinazione</em> &#40;nel nostro caso gradi, quindi <code>u&quot;¬∞&quot;</code>&#41;.</p>
<pre><code class="julia hljs">n(Œ¥) = sin((Œ¥ + Œ±) / <span class=hljs-number >2</span>) / sin(Œ± / <span class=hljs-number >2</span>)
Œ¥(n) = uconvert(<span class=hljs-string >u&quot;¬∞&quot;</span>, <span class=hljs-number >2</span>asin(n * sin(Œ± / <span class=hljs-number >2</span>)) - Œ±)</code></pre><pre><code class="plaintext hljs">Œ¥ (generic function with 1 method)</code></pre>
<p>Queste formule si ricavano banalmente dall&#39;inversione della formula di Cauchy; la funzione <code>A_and_B</code> calcola contemporaneamente <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, ed √® stata definita per comodit√†:</p>
<pre><code class="julia hljs">A(Œª<span class=hljs-number >1</span>, Œ¥<span class=hljs-number >1</span>, Œª<span class=hljs-number >2</span>, Œ¥<span class=hljs-number >2</span>) = (Œª<span class=hljs-number >2</span>^<span class=hljs-number >2</span> * n(Œ¥<span class=hljs-number >2</span>)^<span class=hljs-number >2</span> - Œª<span class=hljs-number >1</span>^<span class=hljs-number >2</span> * n(Œ¥<span class=hljs-number >1</span>)^<span class=hljs-number >2</span>) / (Œª<span class=hljs-number >2</span>^<span class=hljs-number >2</span> - Œª<span class=hljs-number >1</span>^<span class=hljs-number >2</span>)
B(Œª<span class=hljs-number >1</span>, Œ¥<span class=hljs-number >1</span>, Œª<span class=hljs-number >2</span>, Œ¥<span class=hljs-number >2</span>) = (n(Œ¥<span class=hljs-number >2</span>)^<span class=hljs-number >2</span> - n(Œ¥<span class=hljs-number >1</span>)^<span class=hljs-number >2</span>) / (<span class=hljs-number >1</span>/Œª<span class=hljs-number >2</span>^<span class=hljs-number >2</span> - <span class=hljs-number >1</span>/Œª<span class=hljs-number >1</span>^<span class=hljs-number >2</span>)
A_and_B(Œª<span class=hljs-number >1</span>, Œ¥<span class=hljs-number >1</span>, Œª<span class=hljs-number >2</span>, Œ¥<span class=hljs-number >2</span>) = (A(Œª<span class=hljs-number >1</span>, Œ¥<span class=hljs-number >1</span>, Œª<span class=hljs-number >2</span>, Œ¥<span class=hljs-number >2</span>), B(Œª<span class=hljs-number >1</span>, Œ¥<span class=hljs-number >1</span>, Œª<span class=hljs-number >2</span>, Œ¥<span class=hljs-number >2</span>))</code></pre><pre><code class="plaintext hljs">A_and_B (generic function with 1 method)</code></pre>
<p>Calcoliamo allora i valori di riferimento di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy=false >(</mo><msub><mi>Œª</mi><mn>1</mn></msub><mo stretchy=false >)</mo><mo>=</mo><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n(\lambda_1) = n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">Œª</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy=false >(</mo><msub><mi>Œª</mi><mn>2</mn></msub><mo stretchy=false >)</mo><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n(\lambda_2) = n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">Œª</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, supponendo veri i valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> scritti sopra r&#40;<code>A_ref</code> e <code>B_ref</code>&#41;:</p>
<pre><code class="julia hljs">n1_ref, n2_ref = n_cauchy(Œª<span class=hljs-number >1</span>), n_cauchy(Œª<span class=hljs-number >2</span>)</code></pre><pre><code class="plaintext hljs">(1.6967362539886182, 1.751096919705952)</code></pre>
<p>Da <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> calcoliamo quanto aspettarci per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ¥</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\delta_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">Œ¥</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ¥</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\delta_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">Œ¥</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:</p>
<pre><code class="julia hljs">Œ¥<span class=hljs-number >1_</span>ref, Œ¥<span class=hljs-number >2_</span>ref = Œ¥(n1_ref), Œ¥(n2_ref)</code></pre><pre><code class="plaintext hljs">(56.06923804490447¬∞, 62.21990453258211¬∞)</code></pre>
<p>Il vostro codice probabilmente stamper√† angoli in radianti &#40;√® la convenzione di <code>asin</code> in C&#43;&#43;&#41;, quindi convertiamo i valori sopra in modo che possiate confrontarli col risultato del vostro programma:</p>
<pre><code class="julia hljs">println(<span class=hljs-string >&quot;Œ¥1_ref = &quot;</span>, uconvert(<span class=hljs-string >u&quot;rad&quot;</span>, Œ¥<span class=hljs-number >1_</span>ref))
println(<span class=hljs-string >&quot;Œ¥2_ref = &quot;</span>, uconvert(<span class=hljs-string >u&quot;rad&quot;</span>, Œ¥<span class=hljs-number >2_</span>ref))</code></pre><pre><code class="plaintext hljs">Œ¥1_ref = 0.9785928129680513 rad
Œ¥2_ref = 1.0859421943701013 rad
</code></pre>
<p>A questo punto possiamo simulare l&#39;esperimento. La simulazione della misura di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ¥</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\delta_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">Œ¥</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ¥</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\delta_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03785em;">Œ¥</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03785em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> va fatta usando l&#39;approssimazione Gaussiana con i valori medi <code>Œ¥1_ref</code> e <code>Œ¥2_ref</code>, e la deviazione standard <code>œÉ_Œ∏</code> data dal testo dell&#39;esercizio:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simulate_experiment(glc, nsim)
    n1_simul = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, nsim)
    n2_simul = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, nsim)

    A_simul = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}(<span class=hljs-literal >undef</span>, nsim)
    <span class=hljs-comment ># Here I create an array of values whose measurement unit</span>
    <span class=hljs-comment ># must be the same as `Bref`</span>
    B_simul = <span class=hljs-built_in >Array</span>{typeof(Bref)}(<span class=hljs-literal >undef</span>, nsim)

    <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:nsim
        Œ∏<span class=hljs-number >0</span> = randgauss(glc, Œ∏<span class=hljs-number >0_</span>ref, œÉ_Œ∏)
        Œ∏<span class=hljs-number >1</span> = randgauss(glc, Œ∏<span class=hljs-number >0_</span>ref + Œ¥<span class=hljs-number >1_</span>ref, œÉ_Œ∏)
        Œ∏<span class=hljs-number >2</span> = randgauss(glc, Œ∏<span class=hljs-number >0_</span>ref + Œ¥<span class=hljs-number >2_</span>ref, œÉ_Œ∏)
        Œ¥<span class=hljs-number >1</span>, Œ¥<span class=hljs-number >2</span> = Œ∏<span class=hljs-number >1</span> - Œ∏<span class=hljs-number >0</span>, Œ∏<span class=hljs-number >2</span> - Œ∏<span class=hljs-number >0</span>
        n1, n2 = n(Œ¥<span class=hljs-number >1</span>), n(Œ¥<span class=hljs-number >2</span>)
        a, b = A_and_B(Œª<span class=hljs-number >1</span>, Œ¥<span class=hljs-number >1</span>, Œª<span class=hljs-number >2</span>, Œ¥<span class=hljs-number >2</span>)

        n1_simul[i] = n1
        n2_simul[i] = n2

        A_simul[i] = a
        B_simul[i] = b
    <span class=hljs-keyword >end</span>

    (n1_simul, n2_simul, A_simul, B_simul)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">simulate_experiment (generic function with 1 method)</code></pre>
<p>Ecco i primi 5 valori della simulazione; controllate che siano gli stessi che ottenete voi, facendo attenzione di usare come seme <code>1</code> e che l&#39;ordine in cui chiamate la funzione per generare i numeri casuali sia la stessa del codice sopra:</p>
<ol>
<li><p><em>Prima</em> si genera <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∏</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">Œ∏</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>;</p>

<li><p><em>Poi</em> si generano <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∏</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">Œ∏</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∏</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\theta_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">Œ∏</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>

</ol>
<p>Nel fare i plot qui sotto mi limito a ripetere l&#39;esperimento 1000 volte &#40;il testo richiede 10.000 volte&#41;. I risultati non cambiano molto.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
n1_simul, n2_simul, A_simul, B_simul = simulate_experiment(glc, <span class=hljs-number >1000</span>)

<span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14s %14s %14s %14s\n&quot;</span>, <span class=hljs-string >&quot;n‚ÇÅ&quot;</span>, <span class=hljs-string >&quot;n‚ÇÇ&quot;</span>, <span class=hljs-string >&quot;A&quot;</span>, <span class=hljs-string >&quot;B [nm¬≤]&quot;</span>)
println(repeat(<span class=hljs-string >&#x27;-&#x27;</span>, <span class=hljs-number >62</span>))
<span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    <span class=hljs-comment ># We use scientific notation for B, as it is ‚â™1. As we want to</span>
    <span class=hljs-comment ># avoid printing units for B (they are already in the table header),</span>
    <span class=hljs-comment ># we just ¬´strip¬ª nm¬≤ from it.</span>
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14.6f %14.6f %14.6f %14.6e\n&quot;</span>,
            n1_simul[i], n2_simul[i], A_simul[i], ustrip(<span class=hljs-string >u&quot;nm^2&quot;</span>, B_simul[i]))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">            n‚ÇÅ             n‚ÇÇ              A        B [nm¬≤]
--------------------------------------------------------------
      1.696868       1.751023       2.701121   5.977395e+04
      1.696551       1.750981       2.699159   6.007132e+04
      1.696920       1.750983       2.701600   5.967257e+04
      1.697092       1.751081       2.702416   5.959529e+04
      1.696702       1.751176       2.699506   6.012627e+04
</code></pre>
<pre><code class="julia hljs">histogram([n1_simul, n2_simul],
          label = [<span class=hljs-string >&quot;n‚ÇÅ&quot;</span> <span class=hljs-string >&quot;n‚ÇÇ&quot;</span>],
          layout = (<span class=hljs-number >2</span>, <span class=hljs-number >1</span>));</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/hist_n1_n2.svg" alt="">
<pre><code class="julia hljs">scatter(n1_simul, n2_simul, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/scatter_n1_n2.svg" alt="">
<p>Il package <code>Statistics</code> di Julia implementa il calcolo della covarianza tra due serie, che √® uguale alla correlazione a meno di una normalizzazione. Definiamo quindi la funzione <code>corr</code>, che calcola il coefficiente di correlazione, analogamente a questa; nel vostro codice C&#43;&#43; dovrete invece implementarla usando la formula.</p>
<pre><code class="julia hljs">corr(x, y) = cov(x, y) / (std(x) * std(y))</code></pre><pre><code class="plaintext hljs">corr (generic function with 1 method)</code></pre>
<p>I valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ed <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> sono correlati, perch√© sono entrambi stati ricavati dalla medesima stima di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Œ∏</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">Œ∏</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<pre><code class="julia hljs">corr(n1_simul, n2_simul)</code></pre><pre><code class="plaintext hljs">0.502322551936178</code></pre>
<p>Nel fare l&#39;istogramma di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>, rimuoviamo le unit√† di misura da quest&#39;ultimo, perch√© altrimenti Julia segnalerebbe che <code>A_simul</code> e <code>B_simul</code> sono incompatibili &#40;essendo combinati nella stessa chiamata ad <code>histogram</code>&#41;:</p>
<pre><code class="julia hljs">histogram([A_simul, ustrip.(<span class=hljs-string >u&quot;nm^2&quot;</span>, B_simul)],
          label = [<span class=hljs-string >&quot;A&quot;</span> <span class=hljs-string >&quot;B&quot;</span>],
          layout = (<span class=hljs-number >2</span>, <span class=hljs-number >1</span>))</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/hist_A_B.svg" alt="">
<p>Facciamo anche un grafico X-Y</p>
<pre><code class="julia hljs">scatter(A_simul, B_simul, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/scatter_A_B.svg" alt="">
<p>Ricalcoliamo qui i coefficienti di correlazione nel caso in cui l&#39;esperimento sia rifatto 10.000 volte. Notate che creo di nuovo un generatore di numeri casuali.</p>
<pre><code class="julia hljs">glc = GLC(<span class=hljs-number >1</span>)
(n1_simul, n2_simul, A_simul, B_simul) = simulate_experiment(glc, <span class=hljs-number >10_000</span>)
println(<span class=hljs-string >&quot;Correlazione tra n1 e n2: &quot;</span>, corr(n1_simul, n2_simul))
println(<span class=hljs-string >&quot;Correlazione tra A e B: &quot;</span>, corr(A_simul, B_simul))</code></pre><pre><code class="plaintext hljs">Correlazione tra n1 e n2: 0.504788364051966
Correlazione tra A e B: -0.8667564419792286
</code></pre>
<h2 id=esercizio_121_attrito_viscoso_facoltativo ><a href="#esercizio_121_attrito_viscoso_facoltativo" class=header-anchor >Esercizio 12.1 ‚Äî Attrito viscoso &#40;facoltativo&#41;</a></h2>
<p>L&#39;esercizio 12.1 √® preso da un vecchio tema d&#39;esame, e va svolto in modo molto simile al precedente. Si tratta di misurare il coefficiente di viscosit√† <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ∑</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Œ∑</span></span></span></span> partendo dalla velocit√† di caduta di una sferetta di metallo all&#39;interno di un cilindro pieno di glicerina, tramite la formula </p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><msub><mi>v</mi><mi>L</mi></msub><mo>=</mo><mfrac><mrow><mn>2</mn><msup><mi>R</mi><mn>2</mn></msup></mrow><mrow><mn>9</mn><mi>Œ∑</mi></mrow></mfrac><mo stretchy=false >(</mo><mi>œÅ</mi><mo>‚àí</mo><msub><mi>œÅ</mi><mn>0</mn></msub><mo stretchy=false >)</mo><mi>g</mi><mo>=</mo><mfrac><mrow><mi mathvariant=normal >Œî</mi><mi>x</mi></mrow><mrow><mi mathvariant=normal >Œî</mi><mi>t</mi></mrow></mfrac><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex"> v_L =
\frac{2R^2}{9\eta}(\rho - \rho_0) g = \frac{\Delta x}{\Delta t}, </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.371548em;vertical-align:-0.8804400000000001em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.491108em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >9</span><span class="mord mathnormal" style="margin-right:0.03588em;">Œ∑</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >2</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mopen >(</span><span class="mord mathnormal">œÅ</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àí</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">œÅ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.04633em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.36033em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >Œî</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >Œî</span><span class="mord mathnormal">x</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mpunct >,</span></span></span></span></span>
<p>dove <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Œî</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\Delta x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Œî</span><span class="mord mathnormal">x</span></span></span></span> √® la lunghezza del tratto percorso in caduta dalla sferetta e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Œî</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Œî</span><span class="mord mathnormal">t</span></span></span></span> il tempo impiegato. La relazione si inverte facilmente per dare </p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>Œ∑</mi><mo>=</mo><mfrac><mrow><mn>2</mn><msup><mi>R</mi><mn>2</mn></msup><mtext>‚Äâ</mtext><mi>g</mi><mtext>‚Äâ</mtext><mi mathvariant=normal >Œî</mi><mi>t</mi></mrow><mrow><mn>9</mn><mtext>‚Äâ</mtext><mi mathvariant=normal >Œî</mi><mi>x</mi></mrow></mfrac><mo stretchy=false >(</mo><mi>œÅ</mi><mo>‚àí</mo><msub><mi>œÅ</mi><mn>0</mn></msub><mo stretchy=false >)</mo><mo separator=true >,</mo></mrow><annotation encoding="application/x-tex">
\eta = \frac{2R^2\,g\,\Delta t}{9\,\Delta x}(\rho - \rho_0), </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Œ∑</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.177108em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.491108em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >9</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >Œî</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >2</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >Œî</span><span class="mord mathnormal">t</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mopen >(</span><span class="mord mathnormal">œÅ</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àí</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal">œÅ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mpunct >,</span></span></span></span></span>
<p>dove le quantit√† misurate in ognuno degli esperimenti Monte Carlo sono <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Œî</mi><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>‚àí</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\Delta x
= x_1 - x_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Œî</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.73333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >‚àí</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >‚Äã</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Œî</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Œî</span><span class="mord mathnormal">t</span></span></span></span>.</p>
<p>Definiamo le costanti numeriche del problema, usando ancora Unitful.jl:</p>
<pre><code class="julia hljs">Œ¥t, Œ¥x, Œ¥R = <span class=hljs-number >0.01</span>s, <span class=hljs-number >0.001</span>m, <span class=hljs-number >0.0001</span>m;
œÅ, œÅ<span class=hljs-number >0</span> = <span class=hljs-number >2700.0</span><span class=hljs-string >u&quot;kg/m^3&quot;</span>, <span class=hljs-number >1250.0</span><span class=hljs-string >u&quot;kg/m^3&quot;</span>;
g = <span class=hljs-number >9.81</span><span class=hljs-string >u&quot;m/s^2&quot;</span>;
Œ∑_true = <span class=hljs-number >0.83</span><span class=hljs-string >u&quot;kg/m/s&quot;</span>;
R_true = [<span class=hljs-number >0.01</span>m, <span class=hljs-number >0.005</span>m];
x0 = <span class=hljs-number >20</span>cm;
x1 = <span class=hljs-number >60</span>cm;
Œîx_true = x1 - x0;</code></pre>
<p>Definiamo anche alcune relazioni matematiche.</p>
<pre><code class="julia hljs">v_L(R, Œ∑) = <span class=hljs-number >2</span>R^<span class=hljs-number >2</span> / (<span class=hljs-number >9</span>Œ∑) * (œÅ - œÅ<span class=hljs-number >0</span>) * g;
Œît(R, Œîx, Œ∑) = Œîx / v_L(R, Œ∑);
Œît_true = [Œît(R, Œîx_true, Œ∑_true) <span class=hljs-keyword >for</span> R <span class=hljs-keyword >in</span> R_true];
Œ∑(R, Œît, Œîx) = <span class=hljs-number >2</span>R^<span class=hljs-number >2</span> * g * Œît / (<span class=hljs-number >9</span>Œîx) * (œÅ - œÅ<span class=hljs-number >0</span>);</code></pre>
<p>Definiamo ora la funzione <code>simulate</code>, che effettua <em>due</em> esperimenti: uno con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0.01</mn><mtext>‚Äâ</mtext><mtext>m</mtext></mrow><annotation encoding="application/x-tex">R = 0.01\,\text{m}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.01</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >m</span></span></span></span></span> e l&#39;altro con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0.005</mn><mtext>‚Äâ</mtext><mtext>m</mtext></mrow><annotation encoding="application/x-tex">R = 0.005\,\text{m}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.005</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >m</span></span></span></span></span>.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simulate(glc::GLC, Œ¥x, Œ¥t, Œ¥R)
    <span class=hljs-comment ># Misura dell&#x27;altezza iniziale</span>
    cur_x0 = randgauss(glc, x0, Œ¥x)
    <span class=hljs-comment ># Misura dell&#x27;altezza finale</span>
    cur_x1 = randgauss(glc, x1, Œ¥x)

    <span class=hljs-comment ># Questo array di 2 elementi conterr√† le due stime di Œ∑</span>
    <span class=hljs-comment ># (corrispondenti ai due possibili raggi della sferetta)</span>
    estimated_Œ∑ = zeros(typeof(Œ∑_true), <span class=hljs-number >2</span>)
    <span class=hljs-keyword >for</span> case <span class=hljs-keyword >in</span> [<span class=hljs-number >1</span>, <span class=hljs-number >2</span>]
        <span class=hljs-comment ># Misura delle dimensioni della sferetta</span>
        cur_R = randgauss(glc, R_true[case], Œ¥R)
        cur_Œîx = cur_x1 - cur_x0

        <span class=hljs-comment ># Misura del tempo necessario per cadere da cur_x0 a cur_x1</span>
        cur_Œît = randgauss(glc, Œît_true[case], Œ¥t)

        <span class=hljs-comment ># Stima di Œ∑</span>
        estimated_Œ∑[case] = Œ∑(cur_R, cur_Œît, cur_Œîx)
    <span class=hljs-keyword >end</span>

    estimated_Œ∑
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">simulate (generic function with 1 method)</code></pre>
<p>Eseguiamo ora 1000 simulazioni e facciamo l&#39;istogramma della stima di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ∑</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Œ∑</span></span></span></span> per i due raggi della sferetta.</p>
<pre><code class="julia hljs">N = <span class=hljs-number >1_000</span>
glc = GLC(<span class=hljs-number >1</span>)

Œ∑<span class=hljs-number >1</span> = <span class=hljs-built_in >Array</span>{typeof(Œ∑_true)}(<span class=hljs-literal >undef</span>, N)
Œ∑<span class=hljs-number >2</span> = <span class=hljs-built_in >Array</span>{typeof(Œ∑_true)}(<span class=hljs-literal >undef</span>, N)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (Œ∑<span class=hljs-number >1</span>[i], Œ∑<span class=hljs-number >2</span>[i]) = simulate(glc, Œ¥x, Œ¥t, Œ¥R)
<span class=hljs-keyword >end</span>

histogram(Œ∑<span class=hljs-number >2</span>, label=<span class=hljs-string >&quot;R = <span class=hljs-subst >$(R_true[<span class=hljs-number >2</span>])</span>&quot;</span>)
histogram!(Œ∑<span class=hljs-number >1</span>, label=<span class=hljs-string >&quot;R = <span class=hljs-subst >$(R_true[<span class=hljs-number >1</span>])</span>&quot;</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione10/code/output/hist_eta1_eta2.svg" alt="">
<p>Si tratta ora di stimare le incertezze di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Œ∑</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Œ∑</span></span></span></span> al variare degli errori considerati. Notate che per usare <code>round</code> con quantit√† associate ad unit√† di misura √® necessario specificare l&#39;unit√† di misura usata per arrotondare: con 4 cifre, il valore <code>1 m</code> potrebbe essere scritto come <code>1.0000 m</code> oppure <code>100.0000 cm</code>&#33;</p>
<pre><code class="julia hljs"><span class=hljs-comment ># In Œ∑1 ed Œ∑2 abbiamo gi√† le stime di Œ∑ considerando tutti</span>
<span class=hljs-comment ># e tre gli errori</span>
println(<span class=hljs-string >&quot;Tutti gli errori: Œ¥Œ∑(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(Œ∑<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(Œ∑<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))

<span class=hljs-comment ># Ora dobbiamo eseguire di nuovo N esperimenti, assumendo che</span>
<span class=hljs-comment ># l&#x27;errore sia presente in una sola delle tre quantit√†</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (Œ∑<span class=hljs-number >1</span>[i], Œ∑<span class=hljs-number >2</span>[i]) = simulate(glc, <span class=hljs-number >0.0</span>m, <span class=hljs-number >0.0</span>s, Œ¥R)
<span class=hljs-keyword >end</span>
println(<span class=hljs-string >&quot;Solo Œ¥R:          Œ¥Œ∑(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(Œ∑<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(Œ∑<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))

<span class=hljs-comment ># Idem</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (Œ∑<span class=hljs-number >1</span>[i], Œ∑<span class=hljs-number >2</span>[i]) = simulate(glc, <span class=hljs-number >0.0</span>m, Œ¥t, <span class=hljs-number >0.0</span>m)
<span class=hljs-keyword >end</span>
println(<span class=hljs-string >&quot;Solo Œ¥t:          Œ¥Œ∑(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(Œ∑<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(Œ∑<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))

<span class=hljs-comment ># Idem</span>
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:N
    (Œ∑<span class=hljs-number >1</span>[i], Œ∑<span class=hljs-number >2</span>[i]) = simulate(glc, Œ¥x, <span class=hljs-number >0.0</span>s, <span class=hljs-number >0.0</span>m)
<span class=hljs-keyword >end</span>
println(<span class=hljs-string >&quot;Solo Œ¥x:          Œ¥Œ∑(R1) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(Œ∑<span class=hljs-number >1</span>), digits = <span class=hljs-number >4</span>))
println(<span class=hljs-string >&quot;                    (R2) = &quot;</span>, round(<span class=hljs-string >u&quot;kg/m/s&quot;</span>, std(Œ∑<span class=hljs-number >2</span>), digits = <span class=hljs-number >4</span>))</code></pre><pre><code class="plaintext hljs">Tutti gli errori: Œ¥Œ∑(R1) = 0.0188 kg m^-1 s^-1
                    (R2) = 0.0339 kg m^-1 s^-1
Solo Œ¥R:          Œ¥Œ∑(R1) = 0.017 kg m^-1 s^-1
                    (R2) = 0.0338 kg m^-1 s^-1
Solo Œ¥t:          Œ¥Œ∑(R1) = 0.0081 kg m^-1 s^-1
                    (R2) = 0.0021 kg m^-1 s^-1
Solo Œ¥x:          Œ¥Œ∑(R1) = 0.0029 kg m^-1 s^-1
                    (R2) = 0.0029 kg m^-1 s^-1
</code></pre>

<div class=page-foot >
  <div class=copyright >
    &copy; Maurizio Tomasi. Last modified: November 23, 2025. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>