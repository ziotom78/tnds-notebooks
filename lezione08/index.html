<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/tnds-notebooks/libs/katex/katex.min.css"> <link rel=stylesheet  href="/tnds-notebooks/libs/highlight/github.min.css"> <link rel=stylesheet  href="/tnds-notebooks/css/franklin.css"> <link rel=stylesheet  href="/tnds-notebooks/css/poole_hyde.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=icon  href="/tnds-notebooks/assets/favicon.png"> <title>Lezione 8</title> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <h1><a href="/tnds-notebooks/">TNDS</a></h1> <p class=lead >Prof. M.&nbsp;Tomasi</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/tnds-notebooks/">Home</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione07/">Lezione 07</a> <a class="sidebar-nav-item active" href="/tnds-notebooks/lezione08/">Lezione 08</a> <a class="sidebar-nav-item " href="/tnds-notebooks/lezione10/">Lezioni 10 e 11</a> </nav> <p>&copy; Maurizio Tomasi.</p> </div> </div> <div class="content container"> <div class=franklin-content > <p><div class=franklin-toc ><ol><li><a href="#iterare_sui_tempi">Iterare sui tempi</a><li><a href="#esercizio_80_algebra_vettoriale">Esercizio 8.0: Algebra vettoriale</a><li><a href="#esercizio_81_metodo_di_eulero">Esercizio 8.1: metodo di Eulero</a><li><a href="#esercizio_82_soluzione_con_runge-kutta">Esercizio 8.2: Soluzione con Runge-Kutta</a><li><a href="#esercizio_83">Esercizio 8.3</a><li><a href="#esercizio_84">Esercizio 8.4</a></ol></div> </p> <p>In questa lezione implementeremo dei programmi per risolvere equazioni differenziali. Come per la lezione della volta scorsa, mostro qui qual è il risultato atteso per gli esercizi, usando Julia.</p> <h2 id=iterare_sui_tempi ><a href="#iterare_sui_tempi" class=header-anchor >Iterare sui tempi</a></h2> <p>In tutti gli esercizi di oggi si richiede di iterare sul tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>, perché la soluzione numerica delle equazioni differenziali richiede di partire dalla condizione iniziale al tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t = t_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.76508em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e procedere a incrementi di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> finché non si raggiunge il tempo finale <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">t_f</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>:</p> <pre><code class="cpp hljs">std::array&lt;<span class=hljs-type >double</span>, 2&gt; x{...};  <span class=hljs-comment >// Condizione iniziale</span>
<span class=hljs-keyword >while</span> (...) {
    <span class=hljs-comment >// Sovrascrive &quot;x&quot; al tempo t con &quot;x&quot; al tempo t + h</span>
    x = myRK.<span class=hljs-built_in >Passo</span>(t, x, h);
    t += h;
}</code></pre> <p>È importante scrivere bene la condizione nel ciclo <code>while</code>, perché è una cosa che gli studenti sbagliano spesso&#33; Il problema sta negli errori di arrotondamento, che sono dovuti al modo in cui il computer memorizza i numeri <em>floating-point</em> e sono quindi identici sia in C&#43;&#43; che in Julia.</p> <p>Vediamo quindi in cosa consiste il problema usando Julia. Creiamo una variabile <code>t &#61; 0</code> che poi incrementiamo in passi di <code>h &#61; 0.1</code> secondi: in questo modo simuliamo quello che farebbe il ciclo per risolvere una equazione differenziale</p> <pre><code class="julia hljs">t = <span class=hljs-number >0</span>
h = <span class=hljs-number >0.1</span>
t += h</code></pre><pre><code class="plaintext hljs">0.1</code></pre>
<p>Nulla di sorprendente… Incrementiamo ancora un paio di volte:</p>
<pre><code class="julia hljs">t += h
t += h</code></pre><pre><code class="plaintext hljs">0.30000000000000004</code></pre>
<p>Sorpresa&#33; Con tre incrementi si è rivelato un piccolo errore di arrotondamento che era nascosto già nel primo passaggio. Il problema è che il numero <code>0.1</code> con cui incrementavamo ogni volta la variabile <code>t</code> non è rappresentabile nel formato <em>floating-point</em> usato dai calcolatori moderni, che usano lo <a href="https://en.wikipedia.org/wiki/IEEE_754">standard IEE 754</a>. L&#39;errore si è accumulato, passaggio dopo passaggio, diventando visibile solo al terzo passaggio.</p>
<p>Considerate ora un codice come questo, che vorrebbe iterare per <code>t</code> che va da <code>0</code> a <code>1</code> in step di <code>h &#61; 0.1</code>:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simulate(t0, tf, h)
    t = t0

    println(<span class=hljs-string >&quot;Inizia la simulazione, da t=<span class=hljs-variable >$t0</span> a <span class=hljs-variable >$tf</span> con h=<span class=hljs-variable >$h</span>&quot;</span>)

    <span class=hljs-comment ># Itera finché non abbiamo raggiunto il tempo finale</span>
    <span class=hljs-keyword >while</span> t &lt; tf
        println(<span class=hljs-string >&quot;  t = <span class=hljs-variable >$t</span>&quot;</span>)
        t += h
    <span class=hljs-keyword >end</span>

    println(<span class=hljs-string >&quot;Simulazione terminata a t = <span class=hljs-variable >$t</span>&quot;</span>)
<span class=hljs-keyword >end</span>

simulate(<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>, <span class=hljs-number >0.1</span>)</code></pre><pre><code class="plaintext hljs">Inizia la simulazione, da t=0.0 a 1.0 con h=0.1
  t = 0.0
  t = 0.1
  t = 0.2
  t = 0.30000000000000004
  t = 0.4
  t = 0.5
  t = 0.6
  t = 0.7
  t = 0.7999999999999999
  t = 0.8999999999999999
  t = 0.9999999999999999
Simulazione terminata a t = 1.0999999999999999
</code></pre>
<p>Il codice si è arrestato al tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>≈</mo><mn>1.1</mn></mrow><annotation encoding="application/x-tex">t \approx 1.1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1.1</span></span></span></span> anziché al tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t = 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span>&#33; Questa implementazione di <code>while</code> è molto comune nei compiti scritti dei vostri colleghi degli anni scorsi, ma è ovviamente <strong>sbagliata</strong>. Il modo giusto per implementare questo genere di ciclo è di calcolare il numero di iterazioni &#40;come un intero&#41; e poi fare un ciclo for usando solo variabili intere.</p>
<p>Definiamo quindi una funzione che, dati i tempi iniziale e finale e il passo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>, determina il numero di passi:</p>
<pre><code class="julia hljs">num_of_steps(t0, tf, h) = round(<span class=hljs-built_in >Int</span>, (tf - t0) / h)</code></pre><pre><code class="plaintext hljs">num_of_steps (generic function with 1 method)</code></pre>
<p>Vediamo che con questa funzione l&#39;iterazione termina correttamente, anche se il valore di <code>t</code> non è <em>esattamente</em> quello atteso:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simulate_method1(t0, tf, h)
    println(<span class=hljs-string >&quot;Inizia la simulazione, da t=<span class=hljs-variable >$t0</span> a <span class=hljs-variable >$tf</span> con h=<span class=hljs-variable >$h</span>&quot;</span>)

    <span class=hljs-comment ># Calcola il numero di iterazioni prima di iniziare il ciclo</span>
    <span class=hljs-comment ># vero e proprio</span>
    nsteps = num_of_steps(t0, tf, h)
    t = t0
    <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:nsteps
        println(<span class=hljs-string >&quot;  t = <span class=hljs-variable >$t</span>&quot;</span>)
        <span class=hljs-comment ># Incrementa come al solito</span>
        t += h
    <span class=hljs-keyword >end</span>
    println(<span class=hljs-string >&quot;Simulazione terminata a t = <span class=hljs-variable >$t</span>&quot;</span>)
<span class=hljs-keyword >end</span>

simulate_method1(<span class=hljs-number >0</span>, <span class=hljs-number >1</span>, <span class=hljs-number >0.1</span>)</code></pre><pre><code class="plaintext hljs">Inizia la simulazione, da t=0 a 1 con h=0.1
  t = 0
  t = 0.1
  t = 0.2
  t = 0.30000000000000004
  t = 0.4
  t = 0.5
  t = 0.6
  t = 0.7
  t = 0.7999999999999999
  t = 0.8999999999999999
Simulazione terminata a t = 0.9999999999999999
</code></pre>
<p>In questo caso il ciclo si è arrestato al valore <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>≈</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t \approx 1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span>, con un errore <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mi>t</mi><mo>∼</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>16</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\delta t \sim 10^{-16}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∼</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span> che è trascurabile perché è dello stesso ordine di grandezza dell&#39;errore di arrotondamento atteso per una variabile <code>double</code>: l&#39;implementazione quindi è corretta.</p>
<p>Un secondo metodo è quello di evitare di «accumulare» l&#39;incremento <code>h</code> nella variabile <code>t</code> ad ogni iterazione, ma calcolare ogni volta da capo quest&#39;ultima usando la formula <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><msub><mi>t</mi><mn>0</mn></msub><mo>+</mo><mi>i</mi><mo>⋅</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">t_i = t_0 + i \cdot h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.76508em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.76508em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >⋅</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> simulate_method2(t0, tf, h)
    println(<span class=hljs-string >&quot;Inizia la simulazione, da t=<span class=hljs-variable >$t0</span> a <span class=hljs-variable >$tf</span> con h=<span class=hljs-variable >$h</span>&quot;</span>)

    <span class=hljs-comment ># Calcola il numero di iterazioni prima di iniziare il ciclo vero</span>
    <span class=hljs-comment ># e proprio</span>
    nsteps = num_of_steps(t0, tf, h)
    t = t0
    <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:nsteps
        println(<span class=hljs-string >&quot;  t = <span class=hljs-variable >$t</span>&quot;</span>)
        <span class=hljs-comment ># Ricalcola t partendo da t0 e da h, usando il contatore i</span>
        t = t0 + i * h
    <span class=hljs-keyword >end</span>
    println(<span class=hljs-string >&quot;Simulazione terminata a t = <span class=hljs-variable >$t</span>&quot;</span>)
<span class=hljs-keyword >end</span>

simulate_method2(<span class=hljs-number >0</span>, <span class=hljs-number >1</span>, <span class=hljs-number >0.1</span>)</code></pre><pre><code class="plaintext hljs">Inizia la simulazione, da t=0 a 1 con h=0.1
  t = 0
  t = 0.1
  t = 0.2
  t = 0.30000000000000004
  t = 0.4
  t = 0.5
  t = 0.6000000000000001
  t = 0.7000000000000001
  t = 0.8
  t = 0.9
Simulazione terminata a t = 1.0
</code></pre>
<p>Non c&#39;è una grande differenza tra i due metodi: entrambi producono piccoli errori di arrotondamento qua e là, ma la precisione complessiva è confrontabile, e soprattutto in nessuno dei due casi l&#39;errore si accumula. Sentitevi quindi liberi di implementare il metodo che volete nei vostri codici &#40;potete implementarne uno in un esercizio, e l&#39;altro nell&#39;esercizio successivo, così fate pratica con entrambi&#41;.</p>
<h2 id=esercizio_80_algebra_vettoriale ><a href="#esercizio_80_algebra_vettoriale" class=header-anchor >Esercizio 8.0: Algebra vettoriale</a></h2>
<p>Testo dell&#39;esercizio: <a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-08.html#esercizio-8.0">carminati-esercizi-08.html</a>.</p>
<p>In Julia non è necessario implementare le operazioni aritmetiche su vettori, perché sono già implementate: basta porre un punto <code>.</code> davanti all&#39;operatore perché questo venga automaticamente propagato sugli elementi di vettori:</p>
<pre><code class="julia hljs">[<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >4</span>] .+ [<span class=hljs-number >3</span>, <span class=hljs-number >7</span>, -<span class=hljs-number >5</span>]</code></pre><pre><code class="plaintext hljs">3-element Vector{Int64}:
  4
  9
 -1</code></pre>
<p>Questo vale per qualsiasi operatore: <code>-</code>, <code>*</code>, ma anche gli operatori di assegnazione <code>&#61;</code>, di incremento <code>&#43;&#61;</code>, e addirittura di chiamata di funzione:</p>
<pre><code class="julia hljs"><span class=hljs-comment ># Applica la funzione `log10` a tutti gli elementi dell&#x27;array</span>
log10.([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >4</span>])</code></pre><pre><code class="plaintext hljs">3-element Vector{Float64}:
 0.0
 0.3010299956639812
 0.6020599913279624</code></pre>
<h2 id=esercizio_81_metodo_di_eulero ><a href="#esercizio_81_metodo_di_eulero" class=header-anchor >Esercizio 8.1: metodo di Eulero</a></h2>
<p>Testo dell&#39;esercizio: <a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-08.html#esercizio-8.1">carminati-esercizi-08.html</a>.</p>
<p>In Julia è semplicissimo definire il metodo di Eulero: basta una riga, se si usano gli operatori con il punto&#33;</p>
<pre><code class="julia hljs">euler(fn, x, t, h) = x .+ fn(t, x) .* h</code></pre><pre><code class="plaintext hljs">euler (generic function with 1 method)</code></pre>
<p>In Julia non c&#39;è bisogno di definire una classe base <code>FunzioneVettorialeBase</code> da cui derivare altre classi come <code>OscillatoreArmonico</code> eccetera: basta passare la funzione nel parametro <code>fn</code> &#40;primo argomento&#41;. È un meccanismo simile a quello visto nella lezione precedente usando i template, anche se in Julia la risoluzione dei template avviene a <em>runtime</em> anziché in fase di compilazione come in C&#43;&#43;.</p>
<p>Definiamo ora una funzione che descriva l&#39;oscillatore armonico del problema 8.1.</p>
<pre><code class="julia hljs">oscillatore(time, x) = [x[<span class=hljs-number >2</span>], -x[<span class=hljs-number >1</span>]]  <span class=hljs-comment ># ω0 = 1</span></code></pre><pre><code class="plaintext hljs">oscillatore (generic function with 1 method)</code></pre>
<p>Invochiamo <code>oscillatore</code> usando come condizione iniziale <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>x</mi><mo separator=true >,</mo><mi>v</mi><mo stretchy=false >)</mo><mo>=</mo><mo stretchy=false >(</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(x, v) =
(0, 1)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >)</span></span></span></span>. Vediamo che <code>euler</code> restituisce il valore di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>x</mi><mo separator=true >,</mo><mi>v</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(x, v)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mclose >)</span></span></span></span> calcolato al tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn><mo>+</mo><mi>h</mi><mo>=</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">t = 0 + h = h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >0</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>:</p>
<pre><code class="julia hljs">h = <span class=hljs-number >0.1</span>
result = euler(oscillatore, [<span class=hljs-number >0.</span>, <span class=hljs-number >1.</span>], <span class=hljs-number >0.</span>, h)</code></pre><pre><code class="plaintext hljs">2-element Vector{Float64}:
 0.1
 1.0</code></pre>
<p>Il risultato ha senso: la posizione aumenta da <code>0.0</code> a <code>0.1</code>, ma la velocità sembra non aumentare perché l&#39;incremento è del secondo ordine &#40;è l&#39;accelerazione a far muovere il corpo&#33;&#41;, mentre il metodo di Eulero è del primo ordine, quindi troppo inaccurato per accorgersene dopo un solo step. Se evolviamo ancora una volta, vediamo che finalmente la velocità inizia a diminuire:</p>
<pre><code class="julia hljs"><span class=hljs-comment ># Al posto della condizione iniziale, passiamo `result` (la</span>
<span class=hljs-comment ># soluzione al tempo t=h), e al posto del tempo 0.0 passiamo</span>
<span class=hljs-comment ># il tempo 0.0+h</span>
result = euler(oscillatore, result, <span class=hljs-number >0.</span> + h, h)</code></pre><pre><code class="plaintext hljs">2-element Vector{Float64}:
 0.2
 0.99</code></pre>
<p>Definiamo ora una variabile che contenga il tempo finale a cui la nostra simulazione deve arrestarsi:</p>
<pre><code class="julia hljs">lastt = <span class=hljs-number >70.0</span>;</code></pre>
<p>Per iterare <code>euler</code>, possiamo scrivere una funzione che salva tempo, posizione e velocità in un vettore e lo restituisce. Questa funzione richiede come parametri la condizione iniziale <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent=true ><mi>x</mi><mo>⃗</mo></mover><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\vec x_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.864em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord accent"><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.714em;"><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=accent-body  style="left:-0.20772em;"><span class=overlay  style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, il tempo iniziale <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.76508em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e finale <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">t_f</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, e il passo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>, e restituisce tre vettori:</p>
<ol>
<li><p>Un vettore di tempi</p>

<li><p>Un vettore di posizioni</p>

<li><p>Un vettore di velocità</p>

</ol>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> euler_simulation(x0, t0, tf, h)
    <span class=hljs-comment ># Calcola il numero di iterazioni prima di iniziare il ciclo vero</span>
    <span class=hljs-comment ># e proprio</span>
    nsteps = num_of_steps(t0, tf, h)

    <span class=hljs-comment ># I tre vettori hanno `N + 1` elementi e non `N`, perché vogliamo</span>
    <span class=hljs-comment ># memorizzare anche la condizione iniziale.</span>
    times = zeros(<span class=hljs-built_in >Float64</span>, nsteps + <span class=hljs-number >1</span>)
    pos = zeros(<span class=hljs-built_in >Float64</span>, nsteps + <span class=hljs-number >1</span>)
    vel = zeros(<span class=hljs-built_in >Float64</span>, nsteps + <span class=hljs-number >1</span>)

    <span class=hljs-comment ># Salviamo la condizione iniziale</span>
    times[<span class=hljs-number >1</span>] = t0
    pos[<span class=hljs-number >1</span>] = x0[<span class=hljs-number >1</span>]
    vel[<span class=hljs-number >1</span>] = x0[<span class=hljs-number >2</span>]

    t = t0
    x = x0
    <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:nsteps
        x = euler(oscillatore, x, t, h)
        t += h

        times[i + <span class=hljs-number >1</span>] = t
        pos[i + <span class=hljs-number >1</span>] = x[<span class=hljs-number >1</span>]
        vel[i + <span class=hljs-number >1</span>] = x[<span class=hljs-number >2</span>]
    <span class=hljs-keyword >end</span>

    <span class=hljs-comment ># Contrariamente al C++, una funzione Julia può restituire</span>
    <span class=hljs-comment ># più di un valore</span>
    <span class=hljs-keyword >return</span> (times, pos, vel)
<span class=hljs-keyword >end</span>

times, pos, vel = euler_simulation([<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>], <span class=hljs-number >0.0</span>, lastt, <span class=hljs-number >0.1</span>);</code></pre>
<p>Nel vostro codice C&#43;&#43; non è necessario inventarsi chissà quali metodi per restituire più di un valore &#40;anche se in C&#43;&#43; è possibile, usando ad esempio <a href="https://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a>&#41;: potete semplicemente stampare i valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.76508em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> man mano che li calcolate dentro il ciclo <code>for</code>, oppure aggiungendoli a un punto di un grafico Gnuplot o ROOT.</p>
<p>Stampiamo a video i primi valori, per controllare che siano plausibili:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Printf

<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%.2f\t%f\t%f\n&quot;</span>, times[i], pos[i], vel[i])
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">0.00	0.000000	1.000000
0.10	0.100000	1.000000
0.20	0.200000	0.990000
0.30	0.299000	0.970000
0.40	0.396000	0.940100
</code></pre>
<p>E stampiamo anche gli ultimi:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> (length(times) - <span class=hljs-number >5</span>):length(times)
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%.2f\t%f\t%f\n&quot;</span>, times[i], pos[i], vel[i])
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">69.50	4.890629	31.366165
69.60	8.027245	30.877102
69.70	11.114956	30.074378
69.80	14.122393	28.962882
69.90	17.018682	27.550643
70.00	19.773746	25.848775
</code></pre>
<blockquote>
<p><strong>Numeri per test in C&#43;&#43;</strong></p>
<p>Potete usare questi valori per scrivere una funzione C&#43;&#43; che verifichi l&#39;implementazione con degli <code>assert</code>.</p>
</blockquote>
<p>Nello stabilire il passo di integrazione occorre fare un&#39;osservazione <strong>molto importante</strong>: se vogliamo paragonare la soluzione calcolata da euler, possiamo semplicemente paragonare l&#39;ultimo valore di <code>pos.GetComponente&#40;0&#41;</code> col valore <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy=false >(</mo><mn>70</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\sin(70)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mop >sin</span><span class=mopen >(</span><span class=mord >70</span><span class=mclose >)</span></span></span></span>. Ma questo funziona se effettivamente il valore della variabile <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> durante l&#39;ultima iterazione del ciclo <code>for</code> è uguale a 70, e questo vale solo se <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Δ</mi><mi>t</mi><mo>=</mo><mn>70</mn><mtext> </mtext><mtext>s</mtext></mrow><annotation encoding="application/x-tex">\Delta t = 70\,\text{s}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Δ</span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >70</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >s</span></span></span></span></span> è esattamente divisibile per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>.</p>
<p>Chiarisco il problema con un esempio: se devo fare una simulazione da <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mtext> </mtext><mtext>s</mtext></mrow><annotation encoding="application/x-tex">t_0 = 0\,\text{s}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.76508em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >s</span></span></span></span></span> fino a <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>f</mi></msub><mo>=</mo><mn>5</mn><mtext> </mtext><mtext>s</mtext></mrow><annotation encoding="application/x-tex">t_f = 5\,\text{s}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >5</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >s</span></span></span></span></span>, ma uso il passo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>2</mn><mtext> </mtext><mtext>s</mtext></mrow><annotation encoding="application/x-tex">h = 2\,\text{s}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >2</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >s</span></span></span></span></span>, non raggiungerò mai il valore di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">t_f</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, perché la sequenza dei tempi sarà <code>0, 2, 4, 6, …</code>, e non potrò conoscere quindi il valore della soluzione al tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>5</mn><mtext> </mtext><mtext>s</mtext></mrow><annotation encoding="application/x-tex">t = 5\,\text{s}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >5</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >s</span></span></span></span></span>.</p>
<p>Non scegliete quindi a caso i valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>, ma definiteli sempre in funzione del numero di passi che volete far compiere. Il modo più sicuro è di definire <strong>prima</strong> il numero <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> di passi, e poi stabilire il valore di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> dalla formula</p>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>h</mi><mo>=</mo><mfrac><mrow><msub><mi>t</mi><mi>f</mi></msub><mo>−</mo><msub><mi>t</mi><mn>0</mn></msub></mrow><mi>N</mi></mfrac><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex">
h = \frac{t_f - t_0}N.
</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.9780799999999998em;vertical-align:-0.686em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.29208em;"><span style="top:-2.314em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mord >.</span></span></span></span></span>
<p>Nel codice Julia faremo esattamente così: definiamo un vettore di valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>, chiamato <code>nsteps</code>, usando la formula <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">7\times 10^k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >7</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.849108em;vertical-align:0em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>, con <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mo stretchy=false >[</mo><mn>2</mn><mo separator=true >,</mo><mn>2.2</mn><mo separator=true >,</mo><mn>2.4</mn><mo separator=true >,</mo><mn>2.6</mn><mo separator=true >,</mo><mo>…</mo><mo separator=true >,</mo><mn>3.8</mn><mo separator=true >,</mo><mn>4</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">k \in [2, 2.2, 2.4, 2.6, \ldots, 3.8, 4]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >2</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >2.2</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >2.4</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >2.6</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=minner >…</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >3.8</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >4</span><span class=mclose >]</span></span></span></span>: in questo modo i valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> agli estremi sono 700 e 70000, che portano ad <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">h =
10^{-1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">h = 10^{-3}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span>. Il valore di <code>nsteps</code> deve ovviamente essere sempre arrotondato ad un intero &#40;mediante <code>round</code>&#41;.</p>
<pre><code class="julia hljs">nsteps = <span class=hljs-number >7</span> * round.(<span class=hljs-built_in >Int</span>, exp10.(<span class=hljs-number >2</span>:<span class=hljs-number >0.2</span>:<span class=hljs-number >4</span>))</code></pre><pre><code class="plaintext hljs">11-element Vector{Int64}:
   700
  1106
  1757
  2786
  4417
  7000
 11095
 17584
 27867
 44170
 70000</code></pre>
<p>In <code>deltat</code> memorizziamo invece i passi temporali &#40;ossia, i valori di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>&#41; che studieremo più sotto. Come spiegato per l&#39;esercizio 8.0, in Julia l&#39;operatore <code>./</code> è come l&#39;operatore <code>/</code> di divisione, ma viene applicato uno ad uno ad ogni elemento dell&#39;array, e risparmia la noia di dover implementare un ciclo <code>for</code>.</p>
<pre><code class="julia hljs">deltat = lastt ./ nsteps</code></pre><pre><code class="plaintext hljs">11-element Vector{Float64}:
 0.1
 0.06329113924050633
 0.0398406374501992
 0.02512562814070352
 0.01584786053882726
 0.01
 0.006309148264984227
 0.003980891719745223
 0.0025119316754584277
 0.001584786053882726
 0.001</code></pre>
<p>Creiamo ora un&#39;animazione che confronti la soluzione analitica esatta <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>=</mo><mi>sin</mi><mo>⁡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = \sin x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.66786em;vertical-align:0em;"></span><span class=mop >sin</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span></span></span></span> con la soluzione calcolata col metodo <code>euler</code>. In Julia è semplicissimo creare animazioni: basta usare la macro <code>@animate</code> del pacchetto <a href="https://github.com/JuliaPlots/Plots.jl/">Plots</a>, e poi salvare il risultato in un file GIF.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Plots

anim = <span class=hljs-meta >@animate</span> <span class=hljs-keyword >for</span> h <span class=hljs-keyword >in</span> deltat
    (time, pos, vel) = euler_simulation([<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>], <span class=hljs-number >0.0</span>, lastt, h)
    plot(time, pos,
         title = <span class=hljs-meta >@sprintf</span>(<span class=hljs-string >&quot;h = %.5f&quot;</span>, h),
         label=<span class=hljs-string >&quot;Eulero&quot;</span>, ylim=(-<span class=hljs-number >2</span>, <span class=hljs-number >2</span>),
         xlabel=<span class=hljs-string >&quot;Tempo [s]&quot;</span>, ylabel=<span class=hljs-string >&quot;Posizione [m]&quot;</span>)
    plot!(time, sin.(time), label = <span class=hljs-string >&quot;Risultato atteso&quot;</span>)
<span class=hljs-keyword >end</span>

gif(anim, joinpath(<span class=hljs-meta >@OUTPUT</span>, <span class=hljs-string >&quot;euler.gif&quot;</span>), fps = <span class=hljs-number >1</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/euler.gif" alt="">
<p>Vediamo che l&#39;errore è estremamente significativo se <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">h = 10^{-2}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>. Facciamo un confronto più quantitativo confrontando il valore della posizione all&#39;istante <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>70</mn><mtext> </mtext><mtext>s</mtext></mrow><annotation encoding="application/x-tex">t=70\,\text{s}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >70</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >s</span></span></span></span></span> con quello teorico.</p>
<pre><code class="julia hljs">lastpos = [euler_simulation([<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>], <span class=hljs-number >0</span>, lastt, h)[<span class=hljs-number >2</span>][<span class=hljs-keyword >end</span>] <span class=hljs-keyword >for</span> h <span class=hljs-keyword >in</span> deltat]
error_euler = abs.(lastpos .- sin(lastt))

<span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%-14s\t%-14s%-14s\n&quot;</span>, <span class=hljs-string >&quot;δt [s]&quot;</span>, <span class=hljs-string >&quot;x(t = 70 s) [m]&quot;</span>, <span class=hljs-string >&quot;x vero [m]&quot;</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:length(deltat)
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%.12f\t%.12f\t%.12f\n&quot;</span>, deltat[i], lastpos[i], sin(lastt))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">δt [s]        	x(t = 70 s) [m]x vero [m]    
0.100000000000	19.773746013860	0.773890681558
0.063291139241	6.491353718714	0.773890681558
0.039840637450	3.020870585603	0.773890681558
0.025125628141	1.841466606636	0.773890681558
0.015847860539	1.341055498792	0.773890681558
0.010000000000	1.096084090818	0.773890681558
0.006309148265	0.964380218087	0.773890681558
0.003980891720	0.889320788243	0.773890681558
0.002511931675	0.844907752921	0.773890681558
0.001584786054	0.817989996041	0.773890681558
0.001000000000	0.801441124227	0.773890681558
</code></pre>
<p>I numeri sopra vi saranno preziosi per fare test sul vostro codice usando <code>assert</code>. Creiamo ora un plot che mostri l&#39;andamento dell&#39;errore in funzione del passo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>, come mostrato sul sito.</p>
<pre><code class="julia hljs">plot(deltat, error_euler,
     xscale = :log10, yscale = :log10,
     xlabel = <span class=hljs-string >&quot;Passo d&#x27;integrazione&quot;</span>,
     ylabel = <span class=hljs-meta >@sprintf</span>(<span class=hljs-string >&quot;Errore a t = %.1f&quot;</span>, lastt),
     label = <span class=hljs-string >&quot;&quot;</span>)
scatter!(deltat, error_euler, label = <span class=hljs-string >&quot;&quot;</span>);</code></pre><pre><code class="plaintext hljs">&quot;/home/runner/work/tnds-notebooks/tnds-notebooks/__site/assets/lezione08/code/output/euler_error.svg&quot;</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/euler_error.svg" alt="">
<h2 id=esercizio_82_soluzione_con_runge-kutta ><a href="#esercizio_82_soluzione_con_runge-kutta" class=header-anchor >Esercizio 8.2: Soluzione con Runge-Kutta</a></h2>
<p>Testo dell&#39;esercizio: <a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-08.html#esercizio-8.2">carminati-esercizi-08.html</a>.</p>
<p>La funzione <code>rungekutta</code> implementa l&#39;integrazione di Runge-Kutta usando lo stesso approccio della funzione <code>euler</code> vista sopra.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> rungekutta(fn, x, t, h)
    k1 = fn(t, x)
    k2 = fn(t + h / <span class=hljs-number >2.0</span>, x .+ k1 .* h / <span class=hljs-number >2.0</span>)
    k3 = fn(t + h / <span class=hljs-number >2.0</span>, x .+ k2 .* h / <span class=hljs-number >2.0</span>)
    k4 = fn(t + h, x .+ k3 .* h)

    x .+ (k1 .+ <span class=hljs-number >2</span>k2 .+ <span class=hljs-number >2</span>k3 .+ k4) .* h / <span class=hljs-number >6</span>
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">rungekutta (generic function with 1 method)</code></pre>
<p>Dovremmo ora implementare una funzione <code>rk_simulation</code> che, analogamente a quanto avevamo fatto per <code>euler_simulation</code> sopra, iteri per un numero di passi pari al valore restituito da <code>num_of_steps</code>, ma chiamando stavolta <code>rungekutta</code>. Potremmo fare un copia-e-incolla, ma è più elegante pensare a una funzione più generica, che richieda come parametro di input &#40;in <code>method_fn</code>&#41; anche il metodo risolutivo &#40;Eulero o Runge-Kutta&#41;. Già che ci siamo, rendiamo più generica la funzione anche sotto un altro aspetto: invece di aspettarci di usare <code>oscillatore</code> come funzione che descrive l&#39;equazione differenziale da risolvere, accettiamola nel nuovo argomento <code>problem_fn</code>. Ecco quindi la funzione <code>eqdiff_simulation</code>, versione più generale di <code>euler_simulation</code>:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> eqdiff_simulation(method_fn, problem_fn, x0, t0, tf, h)
    nsteps = num_of_steps(t0, tf, h)

    times = zeros(<span class=hljs-built_in >Float64</span>, nsteps + <span class=hljs-number >1</span>)
    pos = zeros(<span class=hljs-built_in >Float64</span>, nsteps + <span class=hljs-number >1</span>)
    vel = zeros(<span class=hljs-built_in >Float64</span>, nsteps + <span class=hljs-number >1</span>)

    times[<span class=hljs-number >1</span>] = t0
    pos[<span class=hljs-number >1</span>] = x0[<span class=hljs-number >1</span>]
    vel[<span class=hljs-number >1</span>] = x0[<span class=hljs-number >2</span>]

    t = t0
    x = x0
    <span class=hljs-keyword >for</span> i = <span class=hljs-number >1</span>:nsteps
        x = method_fn(problem_fn, x, t, h)
        t += h

        times[i + <span class=hljs-number >1</span>] = t
        pos[i + <span class=hljs-number >1</span>] = x[<span class=hljs-number >1</span>]
        vel[i + <span class=hljs-number >1</span>] = x[<span class=hljs-number >2</span>]
    <span class=hljs-keyword >end</span>

    <span class=hljs-keyword >return</span> (times, pos, vel)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">eqdiff_simulation (generic function with 1 method)</code></pre>
<p>Verifichiamo che produca gli stessi risultati di <code>euler_simulation</code>:</p>
<pre><code class="julia hljs">(time_euler, pos_euler, vel_euler) = euler_simulation(
    [<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>],
    <span class=hljs-number >0.0</span>,
    lastt,
    h,
);
(time_eqdiff, pos_eqdiff, vel_eqdiff) = eqdiff_simulation(
    euler,
    oscillatore,
    [<span class=hljs-number >0.0</span>, <span class=hljs-number >1.0</span>],
    <span class=hljs-number >0.0</span>,
    lastt,
    h,
);</code></pre>
<p>Calcoliamo ora il valore assoluto della differenza delle posizioni &#40;farlo sulle velocità sarebbe lo stesso&#41;, e stampiamo il coefficiente più grande:</p>
<pre><code class="julia hljs">maximum(abs.(pos_euler .- pos_eqdiff))</code></pre><pre><code class="plaintext hljs">0.0</code></pre>
<p>Il risultato è 0.0, il che vuol dire che le posizioni ottenute con i due metodi sono uguali: ottimo&#33;</p>
<p>Risolviamo ora il problema dell&#39;oscillatore con Runge-Kutta:</p>
<pre><code class="julia hljs">(time, pos, vel) = eqdiff_simulation(
    rungekutta,
    oscillatore,
    [<span class=hljs-number >0.</span>, <span class=hljs-number >1.</span>],
    <span class=hljs-number >0.0</span>,
    <span class=hljs-number >70.0</span>,
    <span class=hljs-number >0.1</span>,
);</code></pre>
<p>Come sopra, consideriamo visualizziamo i tempi, le posizioni e le velocità all&#39;inizio della simulazione:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Printf

<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%.2f\t%f\t%f\n&quot;</span>, times[i], pos[i], vel[i])
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">0.00	0.000000	1.000000
0.10	0.099833	0.995004
0.20	0.198669	0.980067
0.30	0.295520	0.955337
0.40	0.389418	0.921061
</code></pre>
<p>Questi sono i dati alla fine della simulazione:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> (length(times) - <span class=hljs-number >5</span>):length(times)
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%.2f\t%f\t%f\n&quot;</span>, times[i], pos[i], vel[i])
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">69.50	0.375468	0.926830
69.60	0.466121	0.884716
69.70	0.552116	0.833761
69.80	0.632595	0.774476
69.90	0.706754	0.707453
70.00	0.773850	0.633361
</code></pre>
<blockquote>
<p><strong>Numeri per test in C&#43;&#43;</strong></p>
<p>Potete usare questi valori per scrivere una funzione C&#43;&#43; che verifichi l&#39;implementazione con degli <code>assert</code>.</p>
</blockquote>
<p>Nel caso di Runge-Kutta, l&#39;animazione è molto meno interessante: la convergenza è eccellente anche per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">h = 10^{-1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8141079999999999em;vertical-align:0em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<pre><code class="julia hljs">anim = <span class=hljs-meta >@animate</span> <span class=hljs-keyword >for</span> h <span class=hljs-keyword >in</span> deltat
    cur_result = eqdiff_simulation(
        rungekutta,
        oscillatore,
        [<span class=hljs-number >0.</span>, <span class=hljs-number >1.</span>],
        <span class=hljs-number >0.0</span>,
        <span class=hljs-number >70.0</span>,
        h,
    )
    plot(times, pos,
         title = <span class=hljs-meta >@sprintf</span>(<span class=hljs-string >&quot;h = %.5f&quot;</span>, h),
         label=<span class=hljs-string >&quot;Eulero&quot;</span>, ylim=(-<span class=hljs-number >2</span>, <span class=hljs-number >2</span>),
         xlabel=<span class=hljs-string >&quot;Tempo [s]&quot;</span>, ylabel=<span class=hljs-string >&quot;Posizione [m]&quot;</span>)
    plot!(times, sin.(times), label = <span class=hljs-string >&quot;Risultato atteso&quot;</span>)
<span class=hljs-keyword >end</span>

gif(anim, joinpath(<span class=hljs-meta >@OUTPUT</span>, <span class=hljs-string >&quot;rk.gif&quot;</span>), fps = <span class=hljs-number >1</span>);</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/rk.gif" alt="">
<p>Confrontiamo il grafico dell&#39;errore di Runge-Kutta con quello di Eulero, per rendere evidente la differenza nella velocità di convergenza.</p>
<pre><code class="julia hljs">lastpos = [
    eqdiff_simulation(
        rungekutta,
        oscillatore,
        [<span class=hljs-number >0.</span>, <span class=hljs-number >1.</span>],
        <span class=hljs-number >0.0</span>,
        lastt,
        h,
    )[<span class=hljs-number >2</span>][<span class=hljs-keyword >end</span>] <span class=hljs-keyword >for</span> h <span class=hljs-keyword >in</span> deltat
]
error_rk = abs.(lastpos .- sin(lastt))</code></pre><pre><code class="plaintext hljs">11-element Vector{Float64}:
 4.0570150020236007e-5
 6.301458916779801e-6
 9.680016646029799e-7
 1.5096724137464435e-7
 2.3677510618824726e-8
 3.7318509393813315e-9
 5.891128695978409e-10
 9.315614946103778e-11
 1.4744427900836854e-11
 2.3335777754596165e-12
 3.597122599785507e-13</code></pre>
<p>Questa è la corrispondenza tra <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\delta t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mord mathnormal">t</span></span></span></span> e la posizione finale &#40;a <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>70</mn><mtext> </mtext><mtext>s</mtext></mrow><annotation encoding="application/x-tex">t = 70\,\text{s}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >70</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >s</span></span></span></span></span>&#41;:</p>
<pre><code class="julia hljs"><span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%-14s\t%-14s\t%-14s\n&quot;</span>, <span class=hljs-string >&quot;δt [s]&quot;</span>, <span class=hljs-string >&quot;x(t = 70 s) [m]&quot;</span>, <span class=hljs-string >&quot;x vero [m]&quot;</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:length(deltat)
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%.12f\t%.12f\t%.12f\n&quot;</span>, deltat[i], lastpos[i], sin(lastt))
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">δt [s]        	x(t = 70 s) [m]	x vero [m]    
0.100000000000	0.773850111408	0.773890681558
0.063291139241	0.773884380099	0.773890681558
0.039840637450	0.773889713556	0.773890681558
0.025125628141	0.773890530591	0.773890681558
0.015847860539	0.773890657880	0.773890681558
0.010000000000	0.773890677826	0.773890681558
0.006309148265	0.773890680969	0.773890681558
0.003980891720	0.773890681465	0.773890681558
0.002511931675	0.773890681543	0.773890681558
0.001584786054	0.773890681556	0.773890681558
0.001000000000	0.773890681558	0.773890681558
</code></pre>
<p>Creiamo un plot che mostri visivamente la differenza tra i due metodi:</p>
<pre><code class="julia hljs">plot(deltat, error_euler, label = <span class=hljs-string >&quot;&quot;</span>)
scatter!(deltat, error_euler, label = <span class=hljs-string >&quot;Eulero&quot;</span>)

plot!(deltat, error_rk,
     xscale = :log10, yscale = :log10,
     xlabel = <span class=hljs-string >&quot;Passo d&#x27;integrazione&quot;</span>,
     ylabel = <span class=hljs-meta >@sprintf</span>(<span class=hljs-string >&quot;Errore a t = %.1f&quot;</span>, lastt),
     label = <span class=hljs-string >&quot;&quot;</span>)
scatter!(deltat, error_rk, label = <span class=hljs-string >&quot;Runge-Kutta&quot;</span>)</code></pre><pre><code class="plaintext hljs">&quot;/home/runner/work/tnds-notebooks/tnds-notebooks/__site/assets/lezione08/code/output/euler_rk_comparison.svg&quot;</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/euler_rk_comparison.svg" alt="">
<h2 id=esercizio_83 ><a href="#esercizio_83" class=header-anchor >Esercizio 8.3</a></h2>
<p>Testo dell&#39;esercizio: <a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-08.html#esercizio-8.3">carminati-esercizi-08.html</a>.</p>
<p>Questo esercizio richiede di studiare il comportamento di un pendolo di lunghezza <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> sottoposto ad un&#39;accelerazione di gravità <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>. Impostiamo un paio di costanti.</p>
<pre><code class="julia hljs">rodlength = <span class=hljs-number >1.</span>;
g = <span class=hljs-number >9.81</span>;</code></pre>
<p>La funzione <code>pendulum</code> definisce i due membri dell&#39;equazione differenziale di secondo grado.</p>
<pre><code class="julia hljs">pendulum(t, x) = [x[<span class=hljs-number >2</span>], -g / rodlength * sin(x[<span class=hljs-number >1</span>])]</code></pre><pre><code class="plaintext hljs">pendulum (generic function with 1 method)</code></pre>
<p>Prima di effettuare lo studio richiesto dall&#39;esercizio, è buona norma studiare il comportamento della soluzione in un caso particolare. Usiamo <code>rungekutta</code> per analizzare il caso in cui <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub><mo>=</mo><mi>π</mi><mi mathvariant=normal >/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\theta_0 = \pi / 3</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.84444em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mord >/3</span></span></span></span>:</p>
<pre><code class="julia hljs">times, pos, vel = eqdiff_simulation(
    rungekutta,
    pendulum,
    [<span class=hljs-literal >π</span> / <span class=hljs-number >3</span>, <span class=hljs-number >0.</span>],
    <span class=hljs-number >0.0</span>,
    <span class=hljs-number >3.0</span>,
    <span class=hljs-number >0.01</span>,
)

<span class=hljs-keyword >using</span> Printf

<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >5</span>
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%.2f\t%f\t%f\n&quot;</span>, times[i], pos[i], vel[i])
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">0.00	1.047198	0.000000
0.01	1.046773	-0.084950
0.02	1.045499	-0.169859
0.03	1.043376	-0.254683
0.04	1.040405	-0.339382
</code></pre>
<p>Vedete che la velocità angolare diventa subito negativa: ciò è corretto, se pensate al fatto che la condizione iniziale specifica che il pendolo parta da fermo con un angolo <em>positivo</em>. Visualizziamo come al solito anche le ultime righe:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> (length(times) - <span class=hljs-number >5</span>):length(times)
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%.2f\t%f\t%f\n&quot;</span>, times[i], pos[i], vel[i])
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">2.95	-0.727354	-2.201111
2.96	-0.749036	-2.135092
2.97	-0.770051	-2.067538
2.98	-0.790382	-1.998529
2.99	-0.810017	-1.928140
3.00	-0.828941	-1.856446
</code></pre>
<p>È interessante studiare il pendolo creando un&#39;animazione. Noi useremo il pacchetto <a href="https://github.com/JuliaGraphics/Luxor.jl">Luxor</a>, che consente di creare disegni ed animazioni partendo da forme geometriche primitive. &#40;Se volete creare qualcosa del genere in C&#43;&#43;, potete usare la libreria <a href="https://github.com/ziotom78/monet">Monet</a>, convertendo poi i file SVG generati da Monet in format PNG con l&#39;interfaccia a linea di comando di <a href="https://inkscape.org/">Inkscape</a> e assemblando i file PNG in un&#39;animazione MP4 o MKV con <a href="https://ffmpeg.org/">ffmpeg</a>&#41;.</p>
<p>Per installare Luxor da Internet, usate come al solito i comandi di Pkg:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Pkg
Pkg.add(<span class=hljs-string >&quot;Luxor&quot;</span>)</code></pre>
<p>Quando è installato, possiamo importarlo come al solito:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >import</span> Luxor</code></pre>
<p>In Luxor occorre specificare le dimensioni della superficie su cui si disegna; noi sceglieremo una dimensione di 500×500. Il sistema di coordinate ha origine sempre nel centro dell&#39;immagine, in modo che l&#39;intervallo di valori sugli assi <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> ed <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> sarà nel nostro caso <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>250</mn><mo>…</mo><mn>250</mn></mrow><annotation encoding="application/x-tex">-250\ldots 250</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.72777em;vertical-align:-0.08333em;"></span><span class=mord >−</span><span class=mord >250</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=minner >…</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >250</span></span></span></span>.</p>
<p>La funzione <code>plot_pendulum</code> rappresenta il pendolo come una linea che parte dal centro e alla cui estremità è disegnato un cerchio pieno di colore nero. &#40;Notate che Julia offre il comando <code>sincos</code>, che calcola simultaneamente il valore del seno e del coseno di un angolo&#41;.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> plot_pendulum(angle)
    radius = <span class=hljs-number >200</span>  <span class=hljs-comment ># Lunghezza del braccio del pendolo</span>
    y, x = radius .* sincos(<span class=hljs-literal >π</span> / <span class=hljs-number >2</span> + angle)

    Luxor.sethue(<span class=hljs-string >&quot;black&quot;</span>)
    Luxor.line(Luxor.Point(<span class=hljs-number >0</span>, <span class=hljs-number >0</span>), Luxor.Point(x, y), :stroke)
    Luxor.circle(Luxor.Point(x, y), <span class=hljs-number >10</span>, :fill)
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">plot_pendulum (generic function with 1 method)</code></pre>
<p>Abbiamo già calcolato la soluzione dell&#39;equazione in un caso particolare, e il risultato è nella matrice <code>oscillations</code>. Il comando <code>size</code> restituisce le dimensioni di vettori, matrici e tensori. Nel caso di <code>oscillations</code> ci sono ovviamente 3 colonne, ma il numero di righe &#40;corrispondente agli step temporali&#41; dipende dal passo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> e dalla lunghezza della simulazione. Vediamo di quanti step si tratta:</p>
<pre><code class="julia hljs">size(times, <span class=hljs-number >1</span>)</code></pre><pre><code class="plaintext hljs">301</code></pre>
<p>Creeremo ora un&#39;immagine GIF animata chiamando ripetutamente il comando <code>plot_pendulum</code>. Notate la comodità di Luxor: in poche righe è possibile creare un&#39;intera animazione e salvarla su disco.</p>
<pre><code class="julia hljs">anim = Luxor.Movie(<span class=hljs-number >500</span>, <span class=hljs-number >500</span>, <span class=hljs-string >&quot;Pendulum&quot;</span>)

<span class=hljs-keyword >function</span> animframe(scene, framenumber)
    Luxor.background(<span class=hljs-string >&quot;white&quot;</span>)
    plot_pendulum(pos[framenumber])
<span class=hljs-keyword >end</span>

Luxor.animate(anim, [Luxor.Scene(anim, animframe, <span class=hljs-number >1</span>:size(times, <span class=hljs-number >1</span>))],
    creategif=<span class=hljs-literal >true</span>, pathname=joinpath(<span class=hljs-meta >@OUTPUT</span>, <span class=hljs-string >&quot;pendulum.gif&quot;</span>));</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/pendulum.gif" alt="">
<p>Adesso che abbiamo visto che l&#39;equazione del pendolo viene integrata correttamente, dobbiamo passare al calcolo del periodo di oscillazione. Come suggerito sul sito, bisogna considerare il momento in cui la velocità angolare inverte il segno. Osserviamo allora il grafico della velocità &#40;seconda componente del sistema di equazioni differenziali&#41;.</p>
<pre><code class="julia hljs">plot(times, pos,
     label = <span class=hljs-string >&quot;&quot;</span>,
     xlabel = <span class=hljs-string >&quot;Tempo [s]&quot;</span>,
     ylabel = <span class=hljs-string >&quot;Velocità angolare [rad/s]&quot;</span>);</code></pre><pre><code class="plaintext hljs">&quot;/home/runner/work/tnds-notebooks/tnds-notebooks/__site/assets/lezione08/code/output/oscillations1.svg&quot;</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/oscillations1.svg" alt="">
<p>Come già detto sopra per l&#39;esercizio 8.0, nel vostro codice C&#43;&#43; non è necessario che salviate la soluzione in tre array <code>times</code>, <code>pos</code> e <code>vel</code>. Dal momento che l&#39;esercizio richiede di calcolare il periodo del pendolo, che dipende dal momento in cui avviene l&#39;inversione, possiamo scrivere un ciclo <code>while</code> costruito <em>ad hoc</em> per questo caso. Il procedimento che seguiremo è il seguente:</p>
<ol>
<li><p>Facciamo partire la simulazione; essendo la condizione iniziale <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>θ</mi><mo>=</mo><msub><mi>θ</mi><mn>0</mn></msub><mo separator=true >,</mo><mi>ω</mi><mo>=</mo><mn>0</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(\theta = \theta_0, \omega = 0)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >0</span><span class=mclose >)</span></span></span></span>, il pendolo inizierà a muoversi con velocità angolare <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span> negativa.</p>

<li><p>Continuiamo a far procedere la simulazione, finché non vediamo che il segno di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span></span></span></span> diventa positivo: a questo punto siamo certi che un periodo sia stato completato, e il pendolo sta iniziando a tornare indietro verso angoli positivi.</p>

<li><p>Siccome abbiamo arrestato il ciclo quando <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\omega &gt; 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&gt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>, il tempo passato è un po&#39; più di un semiperiodo: infatti il semiperiodo si ha nel momento esatto in cui <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\omega = 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>. Dobbiamo quindi sottrarre dal tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> una certa quantità. Per stimare questa quantità, possiamo fare una interpolazione lineare tra la velocità all&#39;istante <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">t - h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>, quando ancora <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\omega &lt; 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&lt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>, e il valore attuale di <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>, in cui abbiamo visto che per la prima volta <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\omega &gt; 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&gt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>. Scriviamo quindi la retta <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>=</mo><mi>m</mi><mi>t</mi><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">\omega = m t + q</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> passante per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>t</mi><mo>−</mo><mi>h</mi><mo separator=true >,</mo><msub><mi>ω</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(t - h, \omega_{i-1})</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> e per <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>t</mi><mo separator=true >,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(t, \omega_i)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">t</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> e imponiamo che <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\omega = 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>, ricavando t. Si tratta di un semplice problema di geometria analitica, e la soluzione è la seguente:</p>

</ol>
<span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>t</mi><mo stretchy=false >(</mo><mi>ω</mi><mo stretchy=false >)</mo><mo>=</mo><mi>t</mi><mo>−</mo><mi>h</mi><mo>+</mo><mfrac><mi>h</mi><mrow><msub><mi>ω</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>ω</mi><mi>i</mi></msub></mrow></mfrac><mo fence=true  stretchy=true  minsize=1.2em  maxsize=1.2em >(</mo><msub><mi>ω</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>ω</mi><mo fence=true  stretchy=true  minsize=1.2em  maxsize=1.2em >)</mo><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex">
   t(\omega) = t - h + \frac{h}{\omega_{i - 1} - \omega_i}\bigl(\omega_{i - 1} - \omega\bigr).
   </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:2.265771em;vertical-align:-0.894331em;"></span><span class=mord ><span class="mopen nulldelimiter"></span><span class=mfrac ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:1.37144em;"><span style="top:-2.3139999999999996em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class=pstrut  style="height:3em;"></span><span class=frac-line  style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">h</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.894331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class=mopen ><span class="delimsizing size1">(</span></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mclose ><span class="delimsizing size1">)</span></span><span class=mord >.</span></span></span></span></span>
<p>È facile convincersi della correttezza del risultato, perché    l&#39;espressione è chiaramente una retta, e vale che agli estremi <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy=false >(</mo><msub><mi>ω</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy=false >)</mo><mo>=</mo><mi>t</mi><mo>−</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">t(\omega_{i - 1}) = t - h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy=false >(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy=false >)</mo><mo>=</mo><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t(\omega_i) = \omega_i</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p>Nel nostro caso bisogna quindi implementare il calcolo della formula nel caso in cui <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\omega = 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>, e <strong>raddoppiare il risultato</strong>: lo facciamo nella funzione <code>period</code>, che accetta come parametro la matrice a tre colonne prodotta da <code>eqdiff_simulation</code>, e che sfrutta la funzione <code>invtime</code> che fornisce il valore del tempo all&#39;istante della inversione. Implementiamo una serie di sotto-funzioni, in modo che sia più facile verificare il comportamento di ciascuna. Implementiamo una funzione <code>interp</code> che interpoli tra due coppie di punti <code>ptA</code> <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><msub><mi>t</mi><mi>A</mi></msub><mo separator=true >,</mo><msub><mi>ω</mi><mi>A</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(t_A, \omega_A)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> e <code>ptB</code> <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><msub><mi>t</mi><mi>B</mi></msub><mo separator=true >,</mo><msub><mi>ω</mi><mi>B</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(t_B, \omega_B)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span>, dato un certo valore di <code>ω</code>:</p>
<pre><code class="julia hljs">interp(ptA, ptB, ω) = ptA[<span class=hljs-number >1</span>] - (ptA[<span class=hljs-number >1</span>] - ptB[<span class=hljs-number >1</span>]) / (ptA[<span class=hljs-number >2</span>] - ptB[<span class=hljs-number >2</span>]) * (ptA[<span class=hljs-number >2</span>] - ω)</code></pre><pre><code class="plaintext hljs">interp (generic function with 1 method)</code></pre>
<p>Usiamo l&#39;<em>overloading</em> per definire una versione più specifica, che calcola il valore dell&#39;interpolazione nel caso <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\omega = 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>.</p>
<pre><code class="julia hljs">interp(ptA, ptB) = interp(ptA, ptB, <span class=hljs-number >0</span>)</code></pre><pre><code class="plaintext hljs">interp (generic function with 2 methods)</code></pre>
<p>Eseguiamo una volta <code>interp</code> per trovare il valore dell&#39;ordinata <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> in corrispondenza dell&#39;ordinata <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>0.3</mn></mrow><annotation encoding="application/x-tex">y = 0.3</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0.3</span></span></span></span> di una una retta passante per i punti <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mo>−</mo><mn>0.4</mn><mo separator=true >,</mo><mo>−</mo><mn>0.7</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(-0.4, -0.7)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >−</span><span class=mord >0.4</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >−</span><span class=mord >0.7</span><span class=mclose >)</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mn>0.5</mn><mo separator=true >,</mo><mn>0.8</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(0.5, 0.8)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >0.5</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >0.8</span><span class=mclose >)</span></span></span></span>:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >let</span> p1x = -<span class=hljs-number >0.4</span>, p1y = -<span class=hljs-number >0.7</span>, p2x = <span class=hljs-number >0.5</span>, p2y = <span class=hljs-number >0.8</span>, y = <span class=hljs-number >0.3</span>
    <span class=hljs-comment ># Il comando `plot` richiede di passare un array con le ascisse</span>
    <span class=hljs-comment ># e uno con le coordinate…</span>
    plot([p1x, p2x], [p1y, p2y], label = <span class=hljs-string >&quot;&quot;</span>)
    <span class=hljs-comment ># …mentre la nostra `interp` richiede due coppie (x, y)</span>
    <span class=hljs-keyword >let</span> x = interp([p1x, p1y], [p2x, p2y], y)
        <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;La retta interpolante passa per (%.1f, %.1f)\n&quot;</span>, x, y)
        <span class=hljs-comment ># Il comando `scatter` funziona come `plot`</span>
        scatter!([p1x, x, p2x], [p1y, y, p2y], label = <span class=hljs-string >&quot;&quot;</span>)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">La retta interpolante passa per (0.2, 0.3)
&quot;/home/runner/work/tnds-notebooks/tnds-notebooks/__site/assets/lezione08/code/output/interp-test.svg&quot;</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/interp-test.svg" alt="">
<p>Il grafico mostra che la nostra implementazione di <code>interp</code> funziona a dovere; voi potreste implementare un test nel vostro esercizio:</p>
<pre><code class="cpp hljs"><span class=hljs-function ><span class=hljs-type >void</span> <span class=hljs-title >test_interp</span><span class=hljs-params >()</span> </span>{
  <span class=hljs-type >const</span> <span class=hljs-type >double</span> p1x = <span class=hljs-number >-0.4</span>, p1y = <span class=hljs-number >-0.7</span>;
  <span class=hljs-type >const</span> <span class=hljs-type >double</span> p2x = <span class=hljs-number >0.5</span>, p2y = <span class=hljs-number >0.8</span>;

  <span class=hljs-built_in >assert</span>(<span class=hljs-built_in >are_close</span>(<span class=hljs-built_in >interp</span>(p1x, p1y, p2x, p2y, <span class=hljs-number >0.3</span>), <span class=hljs-number >0.2</span>));
}</code></pre>
<p>Ora possiamo implementare il codice che calcola il periodo</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> period(θ₀; h = <span class=hljs-number >0.01</span>)
    <span class=hljs-comment ># Simuliamo finché ω non diventa negativa</span>

    x = [θ₀, <span class=hljs-number >0.</span>]
    oldx = [<span class=hljs-number >0.</span>, <span class=hljs-number >0.</span>]
    t = <span class=hljs-number >0.0</span>
    <span class=hljs-keyword >while</span> x[<span class=hljs-number >2</span>] ≤ <span class=hljs-number >0</span>
        oldx = x  <span class=hljs-comment ># Ci serve poi per fare l&#x27;interpolazione</span>
        x = rungekutta(pendulum, x, t, h)
        t += h
    <span class=hljs-keyword >end</span>

    <span class=hljs-comment ># A questo punto, t è un po&#x27; più di un semiperiodo.</span>

    <span class=hljs-comment ># Calcoliamo mediante interpolazione l&#x27;istante in cui</span>
    <span class=hljs-comment ># si è avuto ω=0</span>
    t_semip = interp((t - h, oldx[<span class=hljs-number >2</span>]), (t, x[<span class=hljs-number >2</span>]))

    <span class=hljs-comment ># Il periodo è due volte il semiperiodo</span>
    <span class=hljs-keyword >return</span> <span class=hljs-number >2</span>t_semip
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">period (generic function with 1 method)</code></pre>
<p>Confrontiamola col periodo ideale di un pendolo sottoposto a piccole oscillazioni.</p>
<pre><code class="julia hljs">ideal_period = <span class=hljs-number >2</span><span class=hljs-literal >π</span> / √(g / rodlength)</code></pre><pre><code class="plaintext hljs">2.006066680710647</code></pre>
<p>Creiamo ora il grafico analogo a quello riportato nel testo dell&#39;esercizio.</p>
<pre><code class="julia hljs">angles = <span class=hljs-number >0.1</span>:<span class=hljs-number >0.1</span>:<span class=hljs-number >3.0</span>
ampl = [period(angle) <span class=hljs-keyword >for</span> angle <span class=hljs-keyword >in</span> angles]

<span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14s\t%-14s\n&quot;</span>, <span class=hljs-string >&quot;Angolo [rad]&quot;</span>, <span class=hljs-string >&quot;Periodo [s]&quot;</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> eachindex(angles)
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14.1f\t%.7f\n&quot;</span>, angles[i], ampl[i])
<span class=hljs-keyword >end</span>

plot(angles, ampl, label=<span class=hljs-string >&quot;&quot;</span>, xlabel=<span class=hljs-string >&quot;Angolo [rad]&quot;</span>, ylabel=<span class=hljs-string >&quot;Periodo [s]&quot;</span>);
scatter!(angles, ampl, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre><pre><code class="plaintext hljs">  Angolo [rad]	Periodo [s]   
           0.1	2.0073214
           0.2	2.0110933
           0.3	2.0174091
           0.4	2.0263134
           0.5	2.0378677
           0.6	2.0521566
           0.7	2.0692847
           0.8	2.0893812
           0.9	2.1126028
           1.0	2.1391375
           1.1	2.1692090
           1.2	2.2030827
           1.3	2.2410742
           1.4	2.2835593
           1.5	2.3309868
           1.6	2.3838961
           1.7	2.4429402
           1.8	2.5089176
           1.9	2.5828151
           2.0	2.6658708
           2.1	2.7596635
           2.2	2.8662475
           2.3	2.9883659
           2.4	3.1297934
           2.5	3.2959325
           2.6	3.4949131
           2.7	3.7398272
           2.8	4.0538680
           2.9	4.4845820
           3.0	5.1580670
&quot;/home/runner/work/tnds-notebooks/tnds-notebooks/__site/assets/lezione08/code/output/period-vs-angle.svg&quot;</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/period-vs-angle.svg" alt="">
<h2 id=esercizio_84 ><a href="#esercizio_84" class=header-anchor >Esercizio 8.4</a></h2>
<p>Testo dell&#39;esercizio: <a href="https://ziotom78.github.io/tnds-tomasi-notebooks/carminati-esercizi-08.html#esercizio-8.4">carminati-esercizi-08.html</a>.</p>
<p>Come sopra, definiamo i parametri numerici del problema.</p>
<pre><code class="julia hljs">ω<span class=hljs-number >0</span> = <span class=hljs-number >10</span>;
α = <span class=hljs-number >1.0</span> / <span class=hljs-number >30</span>;
endt = <span class=hljs-number >600.0</span>;</code></pre>
<p>Definiamo anche la funzione che caratterizza l&#39;equazione differenziale. Notate che in questo esercizio, per la prima volta, la funzione dipende esplicitamente dalla variabile <code>time</code>, ossia il tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>:</p>
<pre><code class="julia hljs">forcedpendulum(time, x, ω) = [
    x[<span class=hljs-number >2</span>],
    -ω<span class=hljs-number >0</span>^<span class=hljs-number >2</span> * x[<span class=hljs-number >1</span>] - α * x[<span class=hljs-number >2</span>] + sin(ω * time),
]</code></pre><pre><code class="plaintext hljs">forcedpendulum (generic function with 1 method)</code></pre>
<p>Prima di costruire la simulzione, produciamo un grafico usando la funzione <code>eqdiff_simulation</code> definita sopra per capire il comportamento della soluzione. Il plot mostra come il pendolo forzato con smorzante arrivi presto ad una situazione di equilibrio:</p>
<pre><code class="julia hljs"><span class=hljs-comment ># Usiamo `_` per indicare che non ci interessa salvare la velocità</span>
<span class=hljs-comment ># in una variabile, e usiamo una funzione “lambda”</span>
(time, pos, _) = eqdiff_simulation(
    rungekutta,
    (time, x) -&gt; forcedpendulum(time, x, <span class=hljs-number >8.0</span>),
    [<span class=hljs-number >0.</span>, <span class=hljs-number >0.</span>],
    <span class=hljs-number >0.</span>,
    endt,
    <span class=hljs-number >0.1</span>,
)

plot(time, pos, label=<span class=hljs-string >&quot;&quot;</span>, xlabel=<span class=hljs-string >&quot;Tempo [s]&quot;</span>, ylabel=<span class=hljs-string >&quot;Posizione [m]&quot;</span>);</code></pre><pre><code class="plaintext hljs">&quot;/home/runner/work/tnds-notebooks/tnds-notebooks/__site/assets/lezione08/code/output/forced-pendulum.svg&quot;</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/forced-pendulum.svg" alt="">
<p>Rispetto all&#39;esercizio precedente, dobbiamo calcolare qui non il periodo bensì l&#39;ampiezza di oscillazione &#40;che nell&#39;esercizio precedente era fissata dalla condizione iniziale&#41;. Come prima, anche qui non possiamo avere la garanzia che l&#39;integrazione con RK passerà dall&#39;istante in cui il valore della velocità si annulla esattamente, e dovremo quindi usare di nuovo la funzione <code>interp</code>. Il modo migliore di procedere è quindi il seguente:</p>
<ol>
<li><p>Iteriamo RK per un tempo ragionevole in modo da toglierci dalla regione iniziale di instabilità; qui integro fino al tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>15</mn><mi mathvariant=normal >/</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">15/\alpha</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >15/</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>;</p>

<li><p>A questo punto il codice cerca nuovamente una inversione nel segno della velocità;</p>

<li><p>Trovata l&#39;inversione, sappiamo che il massimo avviene in qualche istante che sta tra <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">t + h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span>. Troviamo questo istante <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mtext>inv</mtext></msub></mrow><annotation encoding="application/x-tex">t_\text{inv}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.76508em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31750199999999995em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">inv</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> con una interpolazione lineare tra il punto <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>t</mi><mo separator=true >,</mo><msub><mi>ω</mi><mn>0</mn></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(t,
   \omega_0)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">t</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span> e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >(</mo><mi>t</mi><mo>+</mo><mi>h</mi><mo separator=true >,</mo><msub><mi>ω</mi><mn>1</mn></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">(t + h, \omega_1)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">ω</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span></p>

<li><p>Eseguiamo di nuovo RK partendo dal tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>, ma questa volta non usiamo come incremento <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span></span></span></span> bensì <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mtext>inv</mtext></msub><mo>−</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">t_\text{inv} - t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.76508em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31750199999999995em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">inv</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>. &#40;Alternativamente, si può partire da dove si è arrivati e fare uno step con passo negativo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>t</mi><mo>−</mo><msub><mi>t</mi><mtext>inv</mtext></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h = t - t_\text{inv} &lt; 0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">h</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.76508em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">t</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.31750199999999995em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">inv</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&lt;</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span>: infatti sia il metodo di Eulero che il Runge-Kutta funzionano in entrambe le direzioni temporali&#33;&#41;</p>

<li><p>Se abbiamo fatto le cose per bene, dopo una <em>singola</em> esecuzione di RK ci troviamo in corrispondenza del massimo. Stampare la velocità in questo punto dovrebbe quindi mostrare un numero pressoché nullo</p>

<li><p>Se effettivamente la velocità è praticamente nulla &#40;diciamo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence=true >∣</mo><mi>v</mi><mo fence=true >∣</mo></mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>6</mn></mrow></msup><mtext> </mtext><mtext>rad/s</mtext></mrow><annotation encoding="application/x-tex">\left|v\right| \leq 10^{-6}\,\text{rad/s}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=minner ><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose delimcenter" style="top:0em;">∣</span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≤</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mord ><span class=mord >0</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class=mord >rad/s</span></span></span></span></span>, il valore della posizione in questo punto corrisponde all&#39;ampiezza.</p>

</ol>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> forced_pendulum_amplitude(ω)
    <span class=hljs-comment ># In Julia posso assegnare a una variabile la definizione di una</span>
    <span class=hljs-comment ># funzione!</span>
    fn = (time, x) -&gt; forcedpendulum(time, x, ω)

    <span class=hljs-comment ># Step 1: lascio che la simulazione proceda finché l&#x27;oscillatore</span>
    <span class=hljs-comment ># non si stabilizza</span>

    x = [<span class=hljs-number >0.</span>, <span class=hljs-number >0.</span>]
    t = <span class=hljs-number >0.0</span>

    <span class=hljs-keyword >while</span> t &lt; <span class=hljs-number >15</span> / α
        x = rungekutta(fn, x, t, h)
        t += h
    <span class=hljs-keyword >end</span>

    <span class=hljs-comment ># Step 2: continuo a simulare finché il segno della velocità non</span>
    <span class=hljs-comment ># si inverte</span>

    oldx = [<span class=hljs-number >0.</span>, <span class=hljs-number >0.</span>]
    <span class=hljs-keyword >while</span> <span class=hljs-literal >true</span>
        oldx = x
        x = rungekutta(fn, x, t, h)
        t += h

        <span class=hljs-keyword >if</span> x[<span class=hljs-number >2</span>] * oldx[<span class=hljs-number >2</span>] &lt; <span class=hljs-number >0</span>
            <span class=hljs-keyword >break</span>
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>

    <span class=hljs-comment ># Step 3: eseguo una interpolazione per sapere di quanto</span>
    <span class=hljs-comment ># “arretrare” col tempo. Dovrà essere per forza h_new &lt; 0</span>
    h_new = interp((-h, oldx[<span class=hljs-number >2</span>]), (<span class=hljs-number >0</span>, x[<span class=hljs-number >2</span>]))
    <span class=hljs-meta >@assert</span> h_new &lt; <span class=hljs-number >0</span>

    x = rungekutta(fn, x, t, h_new)

    <span class=hljs-comment ># Devo usare `abs`: non so a priori se il corpo sarà a destra o a</span>
    <span class=hljs-comment ># sinistra dello zero</span>
    <span class=hljs-keyword >return</span> abs(x[<span class=hljs-number >1</span>])
<span class=hljs-keyword >end</span></code></pre><pre><code class="plaintext hljs">forced_pendulum_amplitude (generic function with 1 method)</code></pre>
<p>Chiamiamo la funzione <code>forced_amplitude</code> su un caso specifico: questo è un numero buono per essere usato in un <code>assert</code>. Notate che nel secondo punto &#40;corrispondente al tempo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mi>δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">t + \delta t</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03785em;">δ</span><span class="mord mathnormal">t</span></span></span></span>&#41; la velocità è nulla.</p>
<pre><code class="julia hljs">forced_pendulum_amplitude(<span class=hljs-number >9.5</span>)</code></pre><pre><code class="plaintext hljs">0.11236885617836574</code></pre>
<p>Ricreiamo ora il grafico presente sul sito del corso. La funzione <code>forced_amplitude</code> stampa a video i due punti su cui esegue di nuovo il RK: potete verificare che il secondo punto è effettivamente quello di massimo, perché la velocità è pressoché nulla. Usate i numeri scritti qui sotto per verificare che il vostro codice sia corretto.</p>
<pre><code class="julia hljs"><span class=hljs-comment ># Aggiungiamo 0.01 agli estremi (9 e 11) per evitare la condizione di risonanza</span>
freq = <span class=hljs-number >9.01</span>:<span class=hljs-number >0.05</span>:<span class=hljs-number >11.01</span>
ampl = [forced_pendulum_amplitude(ω) <span class=hljs-keyword >for</span> ω <span class=hljs-keyword >in</span> freq]

<span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14s\t%-14s\n&quot;</span>, <span class=hljs-string >&quot;ω [Hz]&quot;</span>, <span class=hljs-string >&quot;Ampiezza [m]&quot;</span>)
<span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> eachindex(freq)
    <span class=hljs-meta >@printf</span>(<span class=hljs-string >&quot;%14.2f\t%.9f\n&quot;</span>, freq[i], ampl[i])
<span class=hljs-keyword >end</span>

plot(freq, ampl,
     label=<span class=hljs-string >&quot;&quot;</span>, xlabel=<span class=hljs-string >&quot;Frequenza [rad/s]&quot;</span>, ylabel=<span class=hljs-string >&quot;Ampiezza&quot;</span>);
scatter!(freq, ampl, label=<span class=hljs-string >&quot;&quot;</span>);</code></pre><pre><code class="plaintext hljs">        ω [Hz]	Ampiezza [m]  
          9.01	0.055312613
          9.06	0.058435677
          9.11	0.061433676
          9.16	0.065428108
          9.21	0.069135823
          9.26	0.074439247
          9.31	0.079902022
          9.36	0.086671352
          9.41	0.093976526
          9.46	0.103591678
          9.51	0.114312060
          9.56	0.128937200
          9.61	0.146182223
          9.66	0.171004463
          9.71	0.203120780
          9.76	0.251098643
          9.81	0.322386463
          9.86	0.434542823
          9.91	0.584133830
          9.96	0.622486846
         10.01	0.481652699
         10.06	0.348215723
         10.11	0.267258002
         10.16	0.212047762
         10.21	0.176149356
         10.26	0.149165720
         10.31	0.129889992
         10.36	0.114188764
         10.41	0.102407357
         10.46	0.092186372
         10.51	0.083201619
         10.56	0.077112541
         10.61	0.070596611
         10.66	0.066167676
         10.71	0.061280364
         10.76	0.057869529
         10.81	0.054092215
         10.86	0.051333712
         10.91	0.048215540
         10.96	0.046101042
         11.01	0.043584425
&quot;/home/runner/work/tnds-notebooks/tnds-notebooks/__site/assets/lezione08/code/output/forced-pendulum-resonance.svg&quot;</code></pre>
<img src="/tnds-notebooks/assets/lezione08/code/output/forced-pendulum-resonance.svg" alt="">

<div class=page-foot >
  <div class=copyright >
    &copy; Maurizio Tomasi. Last modified: December 13, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>